<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShardMind v2.0 ‚Äî Archaeological Fragment Analysis</title>

    <!-- PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- Three.js for 3D reconstruction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=DM+Sans:wght@400;500;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-primary: #0f1117;
            --bg-secondary: #1a1d28;
            --bg-card: #222633;
            --bg-hover: #2a2e3d;
            --accent: #c9956b;
            --accent-light: #e4b88a;
            --accent-dark: #a07448;
            --text-primary: #e8e6e3;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border: #333847;
            --success: #4ade80;
            --warning: #fbbf24;
            --error: #f87171;
            --info: #60a5fa;
            --cluster-1: #E74C3C; --cluster-2: #3498DB; --cluster-3: #2ECC71;
            --cluster-4: #F39C12; --cluster-5: #9B59B6; --cluster-6: #1ABC9C;
            --radius: 10px;
            --radius-lg: 16px;
            --shadow: 0 4px 24px rgba(0,0,0,0.3);
            --transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-secondary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        /* Loading Screen */
        #loading-screen {
            position: fixed; inset: 0; z-index: 10000;
            background: var(--bg-primary);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            gap: 24px;
            transition: opacity 0.6s ease-out;
        }
        #loading-screen.hidden { opacity: 0; pointer-events: none; display: none !important; }
        .loading-logo {
            font-family: 'Playfair Display', serif;
            font-size: 48px; color: var(--accent);
            animation: pulse 2s ease-in-out infinite;
        }
        .loading-bar {
            width: 200px; height: 3px;
            background: var(--bg-card); border-radius: 3px; overflow: hidden;
        }
        .loading-bar-inner {
            width: 40%; height: 100%;
            background: var(--accent);
            border-radius: 3px;
            animation: loadSlide 1.5s ease-in-out infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        @keyframes loadSlide { 0% { transform: translateX(-100%); } 100% { transform: translateX(350%); } }
        .loading-text { color: var(--text-secondary); font-size: 14px; }
        .loading-packages { color: var(--text-muted); font-size: 12px; font-family: 'JetBrains Mono', monospace; }

        /* Python status indicator (non-blocking) */
        .py-status-bar {
            margin: 8px 12px; padding: 10px 14px;
            border-radius: var(--radius);
            font-size: 12px;
            display: flex; align-items: center; gap: 8px;
            animation: fadeIn 0.3s ease-out;
        }
        .py-status-bar.loading {
            background: rgba(251,191,36,0.1); border: 1px solid rgba(251,191,36,0.25);
            color: var(--warning);
        }
        .py-status-bar.ready {
            background: rgba(74,222,128,0.1); border: 1px solid rgba(74,222,128,0.25);
            color: var(--success);
        }
        .py-status-bar.error {
            background: rgba(248,113,113,0.1); border: 1px solid rgba(248,113,113,0.25);
            color: var(--error);
        }
        .py-status-dot {
            width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
        }
        .py-status-bar.loading .py-status-dot {
            background: var(--warning); animation: pulse 1.2s ease-in-out infinite;
        }
        .py-status-bar.ready .py-status-dot { background: var(--success); }
        .py-status-bar.error .py-status-dot { background: var(--error); }
        .py-retry-btn {
            margin-left: auto; padding: 3px 10px;
            border-radius: 12px; border: 1px solid currentColor;
            background: transparent; color: inherit;
            font-size: 11px; cursor: pointer;
            font-family: 'DM Sans', sans-serif;
        }
        .py-retry-btn:hover { background: rgba(255,255,255,0.1); }

        /* Cookie Banner */
        #cookie-banner {
            position: fixed; bottom: 0; left: 0; right: 0; z-index: 9000;
            background: linear-gradient(135deg, #2a1f14, #1a1520);
            border-top: 2px solid var(--accent);
            padding: 24px 32px; display: none;
            box-shadow: 0 -8px 32px rgba(0,0,0,0.5);
        }
        #cookie-banner.show { display: block; animation: slideUp 0.4s ease-out; }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        .cookie-content { max-width: 1000px; margin: 0 auto; }
        .cookie-title { font-family: 'Playfair Display', serif; font-size: 20px; color: var(--accent); margin-bottom: 8px; }
        .cookie-text { color: var(--text-secondary); font-size: 14px; margin-bottom: 16px; }
        .cookie-options { display: flex; gap: 24px; margin-bottom: 16px; flex-wrap: wrap; }
        .cookie-option { display: flex; align-items: center; gap: 8px; }
        .cookie-option label { font-size: 13px; color: var(--text-secondary); }
        .cookie-btns { display: flex; gap: 12px; flex-wrap: wrap; }

        /* Login Page */
        #login-page {
            min-height: 100vh; display: flex;
            align-items: center; justify-content: center;
            background: radial-gradient(ellipse at 30% 20%, rgba(201,149,107,0.08), transparent 50%),
                        radial-gradient(ellipse at 70% 80%, rgba(100,80,60,0.06), transparent 50%),
                        var(--bg-primary);
        }
        #login-page.hidden { display: none; }
        .login-container {
            width: 100%; max-width: 440px; padding: 20px;
        }
        .login-header {
            text-align: center; margin-bottom: 32px;
        }
        .login-header h1 {
            font-family: 'Playfair Display', serif;
            font-size: 42px; color: var(--accent);
            letter-spacing: 2px;
        }
        .login-header p {
            color: var(--text-secondary); font-size: 15px; margin-top: 8px;
        }
        .login-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 32px;
            box-shadow: var(--shadow);
        }
        .login-tabs {
            display: flex; gap: 0; margin-bottom: 24px;
            border-bottom: 2px solid var(--border);
        }
        .login-tab {
            flex: 1; padding: 12px; text-align: center;
            background: none; border: none;
            color: var(--text-secondary); font-size: 15px; font-weight: 500;
            cursor: pointer; transition: var(--transition);
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            font-family: 'DM Sans', sans-serif;
        }
        .login-tab.active {
            color: var(--accent); border-bottom-color: var(--accent);
        }
        .login-form { display: none; flex-direction: column; gap: 16px; }
        .login-form.active { display: flex; }

        /* Form Elements */
        .form-group { display: flex; flex-direction: column; gap: 6px; }
        .form-group label {
            font-size: 13px; color: var(--text-secondary);
            font-weight: 500; letter-spacing: 0.3px;
        }
        input[type="text"], input[type="password"], input[type="number"],
        select, textarea {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 10px 14px; color: var(--text-primary);
            font-family: 'DM Sans', sans-serif; font-size: 14px;
            transition: var(--transition); outline: none;
            width: 100%;
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(201,149,107,0.15);
        }
        select { cursor: pointer; }

        /* Buttons */
        .btn {
            padding: 10px 20px; border-radius: var(--radius);
            border: 1px solid var(--border); cursor: pointer;
            font-family: 'DM Sans', sans-serif; font-size: 14px; font-weight: 500;
            transition: var(--transition); display: inline-flex;
            align-items: center; gap: 8px; justify-content: center;
        }
        .btn-primary {
            background: var(--accent); color: #1a1d28;
            border-color: var(--accent); font-weight: 600;
        }
        .btn-primary:hover { background: var(--accent-light); transform: translateY(-1px); }
        .btn-secondary {
            background: var(--bg-secondary); color: var(--text-primary);
        }
        .btn-secondary:hover { background: var(--bg-hover); }
        .btn-danger {
            background: rgba(248,113,113,0.15); color: var(--error);
            border-color: rgba(248,113,113,0.3);
        }
        .btn-danger:hover { background: rgba(248,113,113,0.25); }
        .btn-full { width: 100%; }
        .btn-sm { padding: 6px 14px; font-size: 13px; }

        /* App Layout */
        #app-page { display: none; min-height: 100vh; }
        #app-page.active { display: flex; }

        .sidebar {
            width: 300px; min-width: 300px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            height: 100vh; overflow-y: auto;
            padding: 20px; display: flex; flex-direction: column; gap: 16px;
            position: sticky; top: 0;
        }
        .sidebar-header {
            display: flex; align-items: center; justify-content: space-between;
        }
        .sidebar-logo {
            font-family: 'Playfair Display', serif;
            font-size: 24px; color: var(--accent);
        }
        .sidebar-version {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px; color: var(--text-muted);
        }
        .sidebar-user {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 14px; background: rgba(74,222,128,0.08);
            border: 1px solid rgba(74,222,128,0.2);
            border-radius: var(--radius);
        }
        .sidebar-user span { color: var(--success); font-weight: 500; font-size: 14px; }
        .sidebar-divider {
            height: 1px; background: var(--border); margin: 4px 0;
        }
        .sidebar-section-title {
            font-size: 11px; text-transform: uppercase;
            letter-spacing: 1px; color: var(--text-muted);
            font-weight: 600; margin-top: 4px;
        }

        /* File Upload Area */
        .upload-area {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 20px; text-align: center;
            cursor: pointer; transition: var(--transition);
        }
        .upload-area:hover, .upload-area.dragover {
            border-color: var(--accent);
            background: rgba(201,149,107,0.05);
        }
        .upload-area .icon { font-size: 28px; margin-bottom: 6px; }
        .upload-area .label { font-size: 13px; color: var(--text-secondary); }
        .upload-area input { display: none; }
        .upload-files-list {
            display: flex; flex-direction: column; gap: 4px; margin-top: 8px;
        }
        .upload-file-item {
            font-size: 12px; color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            padding: 4px 8px; background: var(--bg-primary);
            border-radius: 4px; display: flex;
            justify-content: space-between; align-items: center;
        }

        /* Slider */
        .slider-group { display: flex; flex-direction: column; gap: 4px; }
        .slider-label {
            font-size: 12px; color: var(--text-secondary);
            display: flex; justify-content: space-between;
        }
        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 4px;
            background: var(--border); border-radius: 4px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            border-radius: 50%; background: var(--accent); cursor: pointer;
            border: 2px solid var(--bg-secondary);
        }

        /* Main Content */
        .main-content {
            flex: 1; overflow-y: auto; height: 100vh;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex; gap: 0; padding: 0 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            overflow-x: auto; position: sticky; top: 0; z-index: 100;
        }
        .tab-btn {
            padding: 14px 18px; background: none; border: none;
            color: var(--text-muted); font-size: 13px; font-weight: 500;
            cursor: pointer; transition: var(--transition);
            white-space: nowrap; border-bottom: 2px solid transparent;
            font-family: 'DM Sans', sans-serif;
        }
        .tab-btn:hover { color: var(--text-secondary); }
        .tab-btn.active {
            color: var(--accent); border-bottom-color: var(--accent);
        }

        .tab-content { display: none; padding: 24px; }
        .tab-content.active { display: block; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

        /* Metrics Row */
        .metrics-row {
            display: flex; gap: 16px; padding: 16px 24px;
            background: var(--bg-secondary); border-bottom: 1px solid var(--border);
        }
        .metric-card {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 12px 20px;
            flex: 1; text-align: center;
        }
        .metric-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px; font-weight: 600; color: var(--accent);
        }
        .metric-label { font-size: 12px; color: var(--text-muted); margin-top: 2px; }

        /* Section Headers */
        .section-header {
            font-family: 'Playfair Display', serif;
            font-size: 28px; color: var(--accent);
            margin-bottom: 20px;
        }
        .section-sub {
            font-size: 14px; color: var(--text-secondary);
            margin-bottom: 16px;
        }

        /* Fragment Gallery */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
        }
        .gallery-item {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            overflow: hidden; cursor: pointer;
            transition: var(--transition);
        }
        .gallery-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            border-color: var(--accent);
        }
        .gallery-item img {
            width: 100%; aspect-ratio: 1;
            object-fit: cover; display: block;
        }
        .gallery-item .gallery-info {
            padding: 10px;
        }
        .gallery-item .gallery-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px; color: var(--accent);
            font-weight: 600;
        }
        .gallery-item .gallery-name {
            font-size: 12px; color: var(--text-secondary);
            margin-top: 2px; white-space: nowrap;
            overflow: hidden; text-overflow: ellipsis;
        }
        .gallery-item-border {
            height: 4px; width: 100%;
        }

        /* Group Cards */
        .group-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 20px; margin-bottom: 16px;
        }
        .group-header {
            display: flex; justify-content: space-between;
            align-items: center; margin-bottom: 16px;
        }
        .group-title { font-size: 18px; font-weight: 600; }
        .group-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px; padding: 4px 10px;
            border-radius: 20px; background: rgba(201,149,107,0.15);
            color: var(--accent);
        }
        .group-pieces {
            display: flex; gap: 8px; overflow-x: auto;
            padding: 8px 0;
        }
        .group-piece {
            width: 80px; min-width: 80px;
            border-radius: 8px; overflow: hidden;
            border: 2px solid var(--border);
        }
        .group-piece img {
            width: 100%; aspect-ratio: 1; object-fit: cover;
        }
        .group-actions {
            display: flex; gap: 8px; margin-top: 12px;
        }

        /* Reconstruction Canvas */
        .recon-container {
            display: flex; gap: 24px; flex-wrap: wrap;
        }
        .recon-main { flex: 2; min-width: 400px; }
        .recon-sidebar { flex: 1; min-width: 250px; }
        .recon-canvas-wrapper {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 16px; text-align: center;
        }
        #recon-canvas {
            max-width: 100%; border-radius: var(--radius);
            background: #f5f5f0;
        }
        .match-list {
            display: flex; flex-direction: column; gap: 8px;
        }
        .match-item {
            padding: 10px 14px; background: var(--bg-card);
            border: 1px solid var(--border); border-radius: var(--radius);
            font-size: 13px; color: var(--text-secondary);
            display: flex; justify-content: space-between;
        }
        .match-score {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent); font-weight: 600;
        }

        /* Database */
        .db-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
        }
        .db-item {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 8px;
            text-align: center;
        }
        .db-item img {
            width: 100%; aspect-ratio: 1; object-fit: cover;
            border-radius: 6px;
        }
        .db-item .db-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px; color: var(--text-muted); margin-top: 4px;
        }

        /* Labels */
        .label-options {
            display: flex; gap: 12px; margin-bottom: 20px;
        }
        .label-option {
            padding: 10px 20px; background: var(--bg-card);
            border: 1px solid var(--border); border-radius: var(--radius);
            cursor: pointer; transition: var(--transition);
            font-size: 14px; color: var(--text-secondary);
        }
        .label-option.active {
            border-color: var(--accent); color: var(--accent);
            background: rgba(201,149,107,0.08);
        }

        /* Changelog */
        .changelog-version {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius-lg); padding: 20px; margin-bottom: 16px;
        }
        .changelog-version.current {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px var(--accent);
        }
        .changelog-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px; color: var(--accent); font-weight: 600;
        }
        .changelog-date {
            font-size: 12px; color: var(--text-muted);
        }
        .changelog-list { margin-top: 12px; padding-left: 20px; }
        .changelog-list li {
            font-size: 13px; color: var(--text-secondary);
            margin-bottom: 4px;
        }

        /* Privacy */
        .privacy-content {
            max-width: 700px;
        }
        .privacy-content h2 {
            font-family: 'Playfair Display', serif;
            color: var(--accent); margin: 24px 0 12px;
        }
        .privacy-content h3 {
            color: var(--text-primary); margin: 16px 0 8px;
        }
        .privacy-content p, .privacy-content li {
            color: var(--text-secondary); line-height: 1.6;
            font-size: 14px;
        }
        .privacy-content ul { padding-left: 20px; }

        /* Help */
        .help-content h2 {
            font-family: 'Playfair Display', serif;
            color: var(--accent); margin: 20px 0 12px;
        }
        .help-content p, .help-content li {
            color: var(--text-secondary); line-height: 1.7;
            font-size: 14px;
        }
        .help-content ul { padding-left: 20px; margin: 8px 0; }
        .help-content strong { color: var(--text-primary); }

        /* Toast Notifications */
        .toast-container {
            position: fixed; top: 20px; right: 20px; z-index: 9999;
            display: flex; flex-direction: column; gap: 8px;
        }
        .toast {
            padding: 12px 20px; border-radius: var(--radius);
            font-size: 14px; min-width: 250px;
            box-shadow: var(--shadow);
            animation: toastIn 0.3s ease-out;
        }
        .toast.success { background: rgba(74,222,128,0.15); color: var(--success); border: 1px solid rgba(74,222,128,0.3); }
        .toast.error { background: rgba(248,113,113,0.15); color: var(--error); border: 1px solid rgba(248,113,113,0.3); }
        .toast.info { background: rgba(96,165,250,0.15); color: var(--info); border: 1px solid rgba(96,165,250,0.3); }
        @keyframes toastIn { from { opacity: 0; transform: translateX(40px); } }

        /* Modal */
        .modal-overlay {
            position: fixed; inset: 0; z-index: 8000;
            background: rgba(0,0,0,0.6); display: none;
            align-items: center; justify-content: center;
            backdrop-filter: blur(4px);
        }
        .modal-overlay.show { display: flex; }
        .modal {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius-lg); padding: 32px;
            max-width: 500px; width: 90%;
            box-shadow: 0 24px 48px rgba(0,0,0,0.4);
        }
        .modal h3 { font-family: 'Playfair Display', serif; color: var(--accent); margin-bottom: 16px; }

        /* Demo Section */
        .demo-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .demo-card {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius-lg); padding: 16px;
        }
        .demo-card h4 { font-size: 16px; margin-bottom: 12px; }
        .demo-card canvas {
            width: 100%; border-radius: var(--radius);
            background: #e6e6e1;
        }

        /* Search bar */
        .search-bar {
            display: flex; gap: 8px; max-width: 400px; margin-bottom: 20px;
        }
        .search-bar input { flex: 1; }

        /* Spinner */
        .spinner {
            width: 24px; height: 24px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Progress Bar */
        .progress-bar {
            width: 100%; height: 4px; background: var(--border);
            border-radius: 4px; overflow: hidden; margin: 8px 0;
        }
        .progress-bar-inner {
            height: 100%; background: var(--accent);
            border-radius: 4px; transition: width 0.3s;
            width: 0%;
        }

        /* Language Toggle */
        .lang-toggle {
            display: flex; gap: 0; border: 1px solid var(--border);
            border-radius: var(--radius); overflow: hidden;
        }
        .lang-btn {
            padding: 6px 12px; background: var(--bg-primary);
            border: none; color: var(--text-muted);
            cursor: pointer; font-size: 13px;
            transition: var(--transition);
        }
        .lang-btn.active {
            background: var(--accent); color: var(--bg-primary);
        }

        /* Empty State */
        .empty-state {
            text-align: center; padding: 60px 20px;
            color: var(--text-muted);
        }
        .empty-state .icon { font-size: 48px; margin-bottom: 16px; opacity: 0.5; }
        .empty-state p { font-size: 14px; }

        /* === 3D RECONSTRUCTION VIEWER === */
        .recon-mode-toggle {
            display: flex; gap: 0; margin-bottom: 20px;
            border: 1px solid var(--border); border-radius: var(--radius);
            overflow: hidden;
        }
        .recon-mode-btn {
            flex: 1; padding: 10px 16px; border: none;
            background: var(--bg-secondary); color: var(--text-secondary);
            font-size: 14px; font-weight: 500; cursor: pointer;
            transition: var(--transition); font-family: 'DM Sans', sans-serif;
        }
        .recon-mode-btn:not(:last-child) { border-right: 1px solid var(--border); }
        .recon-mode-btn.active {
            background: var(--accent); color: #fff;
        }
        .recon-mode-btn:hover:not(.active) {
            background: var(--bg-hover); color: var(--text-primary);
        }

        #three-container {
            width: 100%; aspect-ratio: 1;
            border-radius: var(--radius-lg);
            overflow: hidden; position: relative;
            background: #0a0b10;
            border: 1px solid var(--border);
            cursor: grab;
        }
        #three-container:active { cursor: grabbing; }
        #three-container canvas { display: block; width: 100% !important; height: 100% !important; }

        .three-controls {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 12px; margin-top: 16px;
        }
        .three-controls .slider-group {
            background: var(--bg-card);
            padding: 10px 14px; border-radius: var(--radius);
            border: 1px solid var(--border);
        }
        .three-control-row {
            display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px;
        }
        .three-toggle {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 14px; border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 12px; cursor: pointer;
            transition: var(--transition);
        }
        .three-toggle.active {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(201,149,107,0.1);
        }

        .plate-type-selector {
            display: flex; gap: 8px; margin-bottom: 16px;
        }
        .plate-type-btn {
            flex: 1; padding: 12px 8px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            text-align: center; cursor: pointer;
            transition: var(--transition);
            color: var(--text-secondary);
        }
        .plate-type-btn.active {
            border-color: var(--accent);
            background: rgba(201,149,107,0.08);
        }
        .plate-type-btn:hover:not(.active) {
            border-color: var(--text-muted);
        }
        .plate-type-icon { font-size: 28px; display: block; margin-bottom: 4px; }
        .plate-type-name { font-size: 12px; font-weight: 600; }

        .coverage-bar {
            height: 8px; border-radius: 4px;
            background: var(--bg-secondary);
            overflow: hidden; margin-top: 8px;
        }
        .coverage-bar-fill {
            height: 100%; border-radius: 4px;
            background: linear-gradient(90deg, var(--accent-dark), var(--accent));
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .stats-row-3d {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 10px; margin-top: 16px;
        }
        .stat-3d {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 10px;
            text-align: center;
        }
        .stat-3d-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px; color: var(--accent);
            font-weight: 600;
        }
        .stat-3d-lbl {
            font-size: 11px; color: var(--text-muted);
            margin-top: 2px;
        }

        .assembly-progress {
            position: absolute; bottom: 12px; left: 12px; right: 12px;
            background: rgba(15,17,23,0.85); border-radius: var(--radius);
            padding: 10px 14px; backdrop-filter: blur(8px);
            z-index: 10; display: none;
        }
        .assembly-progress-text {
            font-size: 12px; color: var(--text-secondary);
            margin-bottom: 6px;
        }
        .assembly-bar {
            height: 4px; border-radius: 2px;
            background: var(--bg-secondary);
        }
        .assembly-bar-fill {
            height: 100%; border-radius: 2px;
            background: var(--accent);
            transition: width 0.3s;
        }

        .three-hint {
            position: absolute; top: 12px; right: 12px;
            padding: 6px 12px; border-radius: 20px;
            background: rgba(15,17,23,0.7);
            backdrop-filter: blur(8px);
            font-size: 11px; color: var(--text-muted);
            z-index: 10; pointer-events: none;
        }

        /* === DECORATION LINE DRAWING === */
        .deco-viewer {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
        }
        .deco-panel {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius-lg); padding: 16px; position: relative;
        }
        .deco-panel h4 {
            font-size: 14px; color: var(--text-secondary); margin-bottom: 12px;
            font-weight: 500; letter-spacing: 0.3px;
        }
        .deco-panel canvas {
            width: 100%; border-radius: var(--radius);
            background: #1a1a1a;
        }
        .deco-panel.line-drawing canvas {
            background: #faf8f5;
        }
        .deco-controls {
            display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px;
        }
        .deco-select-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px; margin-bottom: 20px;
        }
        .deco-select-item {
            background: var(--bg-card); border: 2px solid var(--border);
            border-radius: var(--radius); padding: 6px; cursor: pointer;
            transition: var(--transition); text-align: center;
        }
        .deco-select-item:hover { border-color: var(--accent); }
        .deco-select-item.selected {
            border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent);
        }
        .deco-select-item img {
            width: 100%; aspect-ratio: 1; object-fit: cover;
            border-radius: 6px;
        }
        .deco-select-item .deco-id {
            font-size: 10px; color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace; margin-top: 4px;
        }
        .deco-params {
            display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
            margin-bottom: 16px;
        }
        .scale-badge {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 4px 12px; background: rgba(201,149,107,0.1);
            border: 1px solid rgba(201,149,107,0.3);
            border-radius: 20px; font-family: 'JetBrains Mono', monospace;
            font-size: 12px; color: var(--accent);
        }
        .deco-overlay-toggle {
            display: flex; align-items: center; gap: 8px;
            padding: 8px 14px; background: var(--bg-secondary);
            border: 1px solid var(--border); border-radius: var(--radius);
            cursor: pointer; transition: var(--transition);
            font-size: 13px; color: var(--text-secondary);
        }
        .deco-overlay-toggle.active {
            border-color: var(--accent); color: var(--accent);
            background: rgba(201,149,107,0.08);
        }

        /* === CULTURE PERIOD CLASSIFICATION === */
        .culture-card {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius-lg); padding: 20px; margin-bottom: 16px;
            position: relative; overflow: hidden;
        }
        .culture-card::before {
            content: ''; position: absolute; top: 0; left: 0;
            width: 4px; height: 100%;
        }
        .culture-card.neolithic::before { background: #8B6914; }
        .culture-card.bronze-age::before { background: #CD7F32; }
        .culture-card.iron-age::before { background: #6B6B6B; }
        .culture-card.roman::before { background: #C41E3A; }
        .culture-card.medieval::before { background: #4A3728; }
        .culture-card.modern::before { background: #2E5090; }
        .culture-card.unknown::before { background: var(--border); }

        .culture-badge {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 4px 12px; border-radius: 20px;
            font-size: 12px; font-weight: 600;
            letter-spacing: 0.3px;
        }
        .culture-badge.neolithic { background: rgba(139,105,20,0.2); color: #D4A843; }
        .culture-badge.bronze-age { background: rgba(205,127,50,0.2); color: #E8A04E; }
        .culture-badge.iron-age { background: rgba(107,107,107,0.2); color: #A0A0A0; }
        .culture-badge.roman { background: rgba(196,30,58,0.2); color: #E84A6A; }
        .culture-badge.medieval { background: rgba(74,55,40,0.2); color: #A08060; }
        .culture-badge.modern { background: rgba(46,80,144,0.2); color: #6090D0; }

        .culture-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 12px;
        }
        .culture-title {
            font-family: 'Playfair Display', serif;
            font-size: 18px; color: var(--text-primary);
        }
        .culture-confidence {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px; color: var(--accent);
        }
        .culture-details {
            display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
            margin-top: 12px;
        }
        .culture-detail {
            padding: 10px; background: var(--bg-secondary);
            border-radius: var(--radius);
        }
        .culture-detail-label {
            font-size: 11px; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .culture-detail-value {
            font-size: 13px; color: var(--text-secondary);
        }
        .culture-criteria {
            margin-top: 16px; padding: 14px;
            background: var(--bg-secondary);
            border-radius: var(--radius);
            border-left: 3px solid var(--accent);
        }
        .culture-criteria h5 {
            font-size: 13px; color: var(--accent);
            margin-bottom: 8px;
        }
        .culture-criteria ul {
            padding-left: 16px; margin: 0;
        }
        .culture-criteria li {
            font-size: 12px; color: var(--text-muted);
            margin-bottom: 2px;
        }
        .culture-criteria li.match {
            color: var(--success); font-weight: 500;
        }

        .culture-select-wrapper {
            margin-bottom: 20px;
        }
        .culture-manual-select {
            display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;
        }
        .culture-chip {
            padding: 6px 14px; border-radius: 20px;
            border: 1px solid var(--border);
            font-size: 13px; cursor: pointer;
            transition: var(--transition);
            background: var(--bg-secondary);
            color: var(--text-secondary);
        }
        .culture-chip:hover { border-color: var(--accent); color: var(--accent); }
        .culture-chip.selected {
            background: rgba(201,149,107,0.15);
            border-color: var(--accent); color: var(--accent);
        }

        .feature-explanation {
            padding: 16px; background: rgba(96,165,250,0.06);
            border: 1px solid rgba(96,165,250,0.15);
            border-radius: var(--radius); margin-bottom: 20px;
        }
        .feature-explanation p {
            font-size: 13px; color: var(--text-secondary); line-height: 1.6;
        }
        .feature-explanation strong { color: var(--info); }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar { display: none; }
            #app-page { flex-direction: column; }
            .main-content { height: auto; min-height: 100vh; }
            .tab-nav { padding: 0 12px; }
            .tab-btn { padding: 10px 12px; font-size: 12px; }
            .tab-content { padding: 16px; }
            .gallery-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; }
            .demo-grid { grid-template-columns: 1fr; }
            .recon-container { flex-direction: column; }
            .metrics-row { flex-wrap: wrap; }
        }

        /* Mobile sidebar toggle */
        .mobile-menu-btn {
            display: none; position: fixed; bottom: 20px; right: 20px;
            z-index: 200; width: 56px; height: 56px;
            border-radius: 50%; background: var(--accent);
            border: none; color: var(--bg-primary); font-size: 24px;
            cursor: pointer; box-shadow: var(--shadow);
        }
        @media (max-width: 768px) {
            .mobile-menu-btn { display: flex; align-items: center; justify-content: center; }
            .sidebar.mobile-open {
                display: flex; position: fixed; z-index: 300;
                left: 0; top: 0; width: 300px;
                box-shadow: 8px 0 32px rgba(0,0,0,0.5);
            }
        }

        /* Custom label list */
        .custom-labels-list { margin-top: 12px; }
        .custom-label-item {
            display: flex; justify-content: space-between;
            align-items: center; padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: var(--radius); margin-bottom: 6px;
            font-size: 13px;
        }
    </style>
</head>
<body>

<!-- ======================= LOADING SCREEN ======================= -->
<div id="loading-screen">
    <div class="loading-logo">üè∫ ShardMind</div>
    <div class="loading-bar"><div class="loading-bar-inner"></div></div>
    <div class="loading-text" id="loading-status">Initializing...</div>
    <div class="loading-packages" id="loading-packages">Loading Python environment...</div>
</div>

<!-- ======================= TOAST CONTAINER ======================= -->
<div class="toast-container" id="toast-container"></div>

<!-- ======================= COOKIE BANNER ======================= -->
<div id="cookie-banner">
    <div class="cookie-content">
        <div class="cookie-title" id="cookie-title">üç™ Wir verwenden Cookies</div>
        <div class="cookie-text" id="cookie-text">
            Diese App verwendet Cookies f√ºr die Funktionalit√§t und zum Speichern Ihrer Einstellungen.
        </div>
        <div class="cookie-options">
            <div class="cookie-option">
                <input type="checkbox" checked disabled id="cookie-necessary">
                <label for="cookie-necessary" id="lbl-cookie-necessary">Notwendige Cookies</label>
            </div>
            <div class="cookie-option">
                <input type="checkbox" checked id="cookie-functional">
                <label for="cookie-functional" id="lbl-cookie-functional">Funktionale Cookies</label>
            </div>
        </div>
        <div class="cookie-btns">
            <button class="btn btn-primary" onclick="acceptAllCookies()">
                <span id="btn-accept-all">‚úÖ Alle akzeptieren</span>
            </button>
            <button class="btn btn-secondary" onclick="acceptNecessaryCookies()">
                <span id="btn-accept-necessary">‚öôÔ∏è Nur notwendige</span>
            </button>
        </div>
    </div>
</div>

<!-- ======================= LOGIN PAGE ======================= -->
<div id="login-page">
    <div class="login-container">
        <div class="login-header">
            <h1>üè∫ ShardMind</h1>
            <p id="login-tagline">Arch√§ologische Fragmentanalyse & Rekonstruktion</p>
        </div>

        <div style="display:flex; justify-content:center; margin-bottom:20px;">
            <div class="lang-toggle">
                <button class="lang-btn active" id="lang-de-btn" onclick="setLanguage('de')">üá©üá™ Deutsch</button>
                <button class="lang-btn" id="lang-en-btn" onclick="setLanguage('en')">üá¨üáß English</button>
            </div>
        </div>

        <div class="login-card">
            <div class="login-tabs">
                <button class="login-tab active" onclick="showLoginTab('login')" id="tab-login-btn">üîê Anmelden</button>
                <button class="login-tab" onclick="showLoginTab('register')" id="tab-register-btn">üìù Registrieren</button>
            </div>

            <form class="login-form active" id="login-form" onsubmit="return handleLogin(event)">
                <div class="form-group">
                    <label id="lbl-username">Benutzername</label>
                    <input type="text" id="login-username" required>
                </div>
                <div class="form-group">
                    <label id="lbl-password">Passwort</label>
                    <input type="password" id="login-password" required>
                </div>
                <button class="btn btn-primary btn-full" type="submit" id="btn-login">üîê Anmelden</button>
                <div id="login-error" style="color:var(--error);font-size:13px;display:none;text-align:center;"></div>
            </form>

            <form class="login-form" id="register-form" onsubmit="return handleRegister(event)">
                <div class="form-group">
                    <label id="lbl-reg-username">Benutzername</label>
                    <input type="text" id="reg-username" required>
                </div>
                <div class="form-group">
                    <label id="lbl-reg-password">Passwort</label>
                    <input type="password" id="reg-password" required>
                </div>
                <div class="form-group">
                    <label id="lbl-reg-confirm">Passwort best√§tigen</label>
                    <input type="password" id="reg-confirm" required>
                </div>
                <div style="padding:10px;background:rgba(96,165,250,0.08);border:1px solid rgba(96,165,250,0.2);border-radius:var(--radius);font-size:13px;color:var(--info);" id="account-info-text">
                    ‚ÑπÔ∏è Dein Account wird im Browser gespeichert
                </div>
                <button class="btn btn-primary btn-full" type="submit" id="btn-register">üìù Registrieren</button>
                <div id="register-msg" style="font-size:13px;display:none;text-align:center;"></div>
            </form>
        </div>

        <div style="text-align:center;margin-top:16px;">
            <span style="color:var(--text-muted);font-size:12px;">üîí <span id="privacy-link-text">Datenschutzerkl√§rung</span> | ShardMind v2.0</span>
        </div>
    </div>
</div>

<!-- ======================= MAIN APP ======================= -->
<div id="app-page">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <span class="sidebar-logo">üè∫ ShardMind</span>
            <span class="sidebar-version">v2.0</span>
        </div>

        <div class="sidebar-user">
            <span>üë§ <span id="sidebar-username"></span></span>
            <button class="btn btn-sm btn-secondary" onclick="handleLogout()" title="Logout">üö™</button>
        </div>

        <div class="lang-toggle" style="width:100%;">
            <button class="lang-btn active" id="app-lang-de" onclick="setLanguage('de')" style="flex:1;">üá©üá™</button>
            <button class="lang-btn" id="app-lang-en" onclick="setLanguage('en')" style="flex:1;">üá¨üáß</button>
        </div>

        <div class="sidebar-divider"></div>

        <!-- Python Engine Status -->
        <div class="py-status-bar loading" id="py-status-bar">
            <div class="py-status-dot"></div>
            <span id="py-status-text">Python-Engine l√§dt...</span>
            <button class="py-retry-btn" id="py-retry-btn" style="display:none;" onclick="retryPyLoad()">‚Üª Retry</button>
        </div>

        <div class="sidebar-section-title" id="sidebar-upload-title">üì§ FOTOS HOCHLADEN</div>
        <div class="upload-area" id="upload-area" onclick="document.getElementById('file-input').click()">
            <div class="icon">üì∑</div>
            <div class="label" id="upload-label">JPG, PNG ‚Äî Scherben auf hellem Hintergrund</div>
            <input type="file" id="file-input" multiple accept=".png,.jpg,.jpeg">
        </div>
        <div class="upload-files-list" id="upload-files-list"></div>

        <div class="sidebar-divider"></div>

        <div class="slider-group">
            <div class="slider-label">
                <span id="lbl-min-size">Min. Fragmentgr√∂√üe</span>
                <span id="val-min-size">150</span>
            </div>
            <input type="range" id="slider-min-size" min="50" max="1000" value="150"
                   oninput="document.getElementById('val-min-size').textContent=this.value">
        </div>

        <div class="slider-group">
            <div class="slider-label">
                <span id="lbl-cluster-sens">Gruppierungsst√§rke</span>
                <span id="val-cluster-sens">40</span>
            </div>
            <input type="range" id="slider-cluster-sens" min="10" max="80" value="40"
                   oninput="document.getElementById('val-cluster-sens').textContent=this.value">
        </div>

        <div class="slider-group">
            <div class="slider-label">
                <span id="lbl-separation">Trennungs-Empfindlichkeit</span>
                <span id="val-separation">0.5</span>
            </div>
            <input type="range" id="slider-separation" min="0" max="10" value="5"
                   oninput="document.getElementById('val-separation').textContent=(this.value/10).toFixed(1)">
        </div>

        <div class="form-group">
            <label id="lbl-detection-mode">Erkennungsmodus</label>
            <select id="select-mode">
                <option value="porcelain">Porzellan/Keramik</option>
                <option value="auto">Automatisch</option>
                <option value="light_bg">Heller Hintergrund</option>
                <option value="dark_bg">Dunkler Hintergrund</option>
                <option value="high_contrast">Hoher Kontrast</option>
            </select>
        </div>

        <div class="form-group">
            <label id="lbl-project">Projekt/Grabung</label>
            <input type="text" id="input-project" value="Project_2025">
        </div>

        <div class="sidebar-divider"></div>

        <button class="btn btn-primary btn-full" id="btn-analyze" onclick="runAnalysis()">
            üî¨ <span id="txt-analyze">Analysieren</span>
        </button>

        <button class="btn btn-secondary btn-full" onclick="clearAnalysis()">
            üóëÔ∏è <span id="txt-clear">Leeren</span>
        </button>

        <div class="sidebar-divider"></div>

        <div style="display:flex;gap:12px;">
            <div class="metric-card" style="flex:1;">
                <div class="metric-value" id="db-fragments-count">0</div>
                <div class="metric-label" id="lbl-db-frags">Fragmente</div>
            </div>
            <div class="metric-card" style="flex:1;">
                <div class="metric-value" id="db-groups-count">0</div>
                <div class="metric-label" id="lbl-db-groups">Gruppen</div>
            </div>
        </div>
    </aside>

    <button class="mobile-menu-btn" onclick="toggleMobileSidebar()">‚ò∞</button>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Metrics Row -->
        <div class="metrics-row" id="metrics-row" style="display:none;">
            <div class="metric-card">
                <div class="metric-value" id="metric-fragments">0</div>
                <div class="metric-label">üè∫ <span id="ml-frags">Fragmente</span></div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="metric-groups">0</div>
                <div class="metric-label">üì¶ <span id="ml-groups">Gruppen</span></div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="metric-project">‚Äî</div>
                <div class="metric-label">üó∫Ô∏è Projekt</div>
            </div>
        </div>

        <!-- Progress -->
        <div id="analysis-progress" style="display:none;padding:16px 24px;">
            <div style="display:flex;align-items:center;gap:12px;">
                <div class="spinner"></div>
                <span id="progress-text">Analysiere...</span>
            </div>
            <div class="progress-bar"><div class="progress-bar-inner" id="progress-bar-inner"></div></div>
        </div>

        <!-- Tab Navigation -->
        <nav class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('start')">üè† <span class="tab-label" data-key="tab_start">Start</span></button>
            <button class="tab-btn" onclick="switchTab('gallery')">üè∫ <span class="tab-label" data-key="tab_gallery">Galerie</span></button>
            <button class="tab-btn" onclick="switchTab('groups')">üì¶ <span class="tab-label" data-key="tab_groups">Gruppen</span></button>
            <button class="tab-btn" onclick="switchTab('reconstruction')">üß© <span class="tab-label" data-key="tab_reconstruction">Rekonstruktion</span></button>
            <button class="tab-btn" onclick="switchTab('decoration')">üé® <span class="tab-label" data-key="tab_decoration">Verzierung</span></button>
            <button class="tab-btn" onclick="switchTab('culture')">üèõÔ∏è <span class="tab-label" data-key="tab_culture">Kulturstufe</span></button>
            <button class="tab-btn" onclick="switchTab('database')">üíæ <span class="tab-label" data-key="tab_database">Datenbank</span></button>
            <button class="tab-btn" onclick="switchTab('labels')">üè∑Ô∏è <span class="tab-label" data-key="tab_labels">Etiketten</span></button>
            <button class="tab-btn" onclick="switchTab('changelog')">üìã <span class="tab-label" data-key="tab_changelog">Changelog</span></button>
            <button class="tab-btn" onclick="switchTab('privacy')">üîí <span class="tab-label" data-key="tab_privacy">Datenschutz</span></button>
            <button class="tab-btn" onclick="switchTab('help')">‚ùì <span class="tab-label" data-key="tab_help">Hilfe</span></button>
        </nav>

        <!-- TAB: Start -->
        <div class="tab-content active" id="tab-start">
            <h2 class="section-header">üè∫ ShardMind</h2>
            <p class="section-sub" id="start-tagline">Analysiere und rekonstruiere zerbrochene Objekte</p>

            <div style="margin-bottom:24px;">
                <h3 style="font-size:18px;margin-bottom:12px;" id="search-title">üîç Fragment suchen</h3>
                <div class="search-bar">
                    <input type="text" id="search-input" placeholder="SM-XXXXXXXX">
                    <button class="btn btn-primary" onclick="searchFragment()">üîç</button>
                </div>
                <div id="search-result"></div>
            </div>

            <hr style="border-color:var(--border);margin:24px 0;">

            <h3 style="font-size:18px;margin-bottom:16px;" id="demo-title">üé® Demo</h3>
            <p style="color:var(--text-secondary);margin-bottom:16px;font-size:14px;" id="demo-hint">
                Herunterladen ‚Üí Links hochladen ‚Üí Analysieren
            </p>

            <div class="demo-grid">
                <div class="demo-card">
                    <h4>üè∫ <span id="demo-pottery-title">Keramik</span></h4>
                    <canvas id="demo-canvas-pottery" width="400" height="400"></canvas>
                    <button class="btn btn-secondary btn-full" style="margin-top:12px;" onclick="downloadDemoImage('pottery')">
                        üì• <span id="demo-dl-pottery">Download</span>
                    </button>
                </div>
                <div class="demo-card">
                    <h4>üçΩÔ∏è <span id="demo-plate-title">Teller</span></h4>
                    <canvas id="demo-canvas-plate" width="400" height="400"></canvas>
                    <button class="btn btn-secondary btn-full" style="margin-top:12px;" onclick="downloadDemoImage('plate')">
                        üì• <span id="demo-dl-plate">Download</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- TAB: Gallery -->
        <div class="tab-content" id="tab-gallery">
            <h2 class="section-header" id="gallery-header">Erkannte Fragmente</h2>
            <div id="gallery-content">
                <div class="empty-state" id="gallery-empty">
                    <div class="icon">üì∑</div>
                    <p id="gallery-empty-text">Bitte zuerst Fotos hochladen</p>
                </div>
            </div>
        </div>

        <!-- TAB: Groups -->
        <div class="tab-content" id="tab-groups">
            <h2 class="section-header" id="groups-header">Gruppierung</h2>
            <div id="groups-content">
                <div class="empty-state">
                    <div class="icon">üì¶</div>
                    <p id="groups-empty-text">Bitte zuerst Fotos hochladen</p>
                </div>
            </div>
        </div>

        <!-- TAB: Reconstruction -->
        <div class="tab-content" id="tab-reconstruction">
            <h2 class="section-header" id="recon-header">üß© Rekonstruktion</h2>
            
            <div class="recon-mode-toggle">
                <button class="recon-mode-btn active" onclick="setReconMode('2d', this)">üìê 2D-Ansicht</button>
                <button class="recon-mode-btn" onclick="setReconMode('3d', this)">üîÆ 3D-Modell</button>
            </div>

            <!-- 2D Reconstruction (existing) -->
            <div id="recon-2d-panel">
                <div id="recon-content">
                    <div class="empty-state">
                        <div class="icon">üß©</div>
                        <p id="recon-empty-text">Bitte zuerst Fotos hochladen und analysieren</p>
                    </div>
                </div>
            </div>

            <!-- 3D Reconstruction (new) -->
            <div id="recon-3d-panel" style="display:none;">
                <div id="recon-3d-empty" class="empty-state">
                    <div class="icon">üîÆ</div>
                    <p>Bitte zuerst Fotos hochladen und analysieren</p>
                </div>

                <div id="recon-3d-main" style="display:none;">
                    <div class="feature-explanation">
                        <p>
                            <strong>3D-Rekonstruktion:</strong>
                            <span id="txt-3d-explain">Die Fragmente werden auf ein parametrisches 3D-Tellermodell projiziert. Die Tellerform basiert auf dem Circle-Fitting der Dekorb√§nder. W√§hlen Sie den Gef√§√ütyp und passen Sie Tiefe und Randwinkel an.</span>
                        </p>
                    </div>

                    <!-- Plate type selector -->
                    <div class="plate-type-selector">
                        <div class="plate-type-btn active" onclick="selectPlateType('flat', this)">
                            <span class="plate-type-icon">üçΩÔ∏è</span>
                            <span class="plate-type-name">Flachteller</span>
                        </div>
                        <div class="plate-type-btn" onclick="selectPlateType('soup', this)">
                            <span class="plate-type-icon">ü•£</span>
                            <span class="plate-type-name">Suppenteller</span>
                        </div>
                        <div class="plate-type-btn" onclick="selectPlateType('bowl', this)">
                            <span class="plate-type-icon">ü•ó</span>
                            <span class="plate-type-name">Sch√ºssel</span>
                        </div>
                        <div class="plate-type-btn" onclick="selectPlateType('cup', this)">
                            <span class="plate-type-icon">‚òï</span>
                            <span class="plate-type-name">Tasse</span>
                        </div>
                    </div>

                    <!-- Group selector -->
                    <div class="form-group" style="margin-bottom:16px;">
                        <label>Gruppe w√§hlen</label>
                        <select id="recon-3d-group-select"></select>
                    </div>

                    <!-- 3D Controls -->
                    <div class="three-controls">
                        <div class="slider-group">
                            <div class="slider-label"><span>Tiefe (mm)</span><span id="val-plate-depth">15</span></div>
                            <input type="range" id="slider-plate-depth" min="3" max="60" value="15" step="1"
                                   oninput="document.getElementById('val-plate-depth').textContent=this.value; update3DPlate();">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label"><span>Randwinkel (¬∞)</span><span id="val-rim-angle">25</span></div>
                            <input type="range" id="slider-rim-angle" min="5" max="75" value="25" step="1"
                                   oninput="document.getElementById('val-rim-angle').textContent=this.value; update3DPlate();">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label"><span>Standfu√ü (%)</span><span id="val-base-frac">20</span></div>
                            <input type="range" id="slider-base-frac" min="10" max="50" value="20" step="1"
                                   oninput="document.getElementById('val-base-frac').textContent=this.value; update3DPlate();">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label"><span>Wandst√§rke</span><span id="val-wall-thick">3</span></div>
                            <input type="range" id="slider-wall-thick" min="1" max="8" value="3" step="0.5"
                                   oninput="document.getElementById('val-wall-thick').textContent=this.value; update3DPlate();">
                        </div>
                    </div>

                    <button class="btn btn-primary btn-full" style="margin-top:16px;" onclick="run3DReconstruction()">
                        üîÆ 3D-Rekonstruktion starten
                    </button>

                    <!-- 3D Viewport -->
                    <div id="three-container" style="margin-top:16px;display:none;">
                        <div class="three-hint">üñ±Ô∏è Ziehen = Drehen | Scrollen = Zoom | Rechtsklick = Verschieben</div>
                        <div class="assembly-progress" id="assembly-progress">
                            <div class="assembly-progress-text" id="assembly-progress-text">Montage...</div>
                            <div class="assembly-bar"><div class="assembly-bar-fill" id="assembly-bar-fill" style="width:0%"></div></div>
                        </div>
                    </div>

                    <div class="three-control-row" id="three-toggles" style="display:none;">
                        <div class="three-toggle active" onclick="toggle3DOption(this,'texture')">üé® Textur</div>
                        <div class="three-toggle" onclick="toggle3DOption(this,'wireframe')">üî≤ Drahtgitter</div>
                        <div class="three-toggle" onclick="toggle3DOption(this,'fragments')">üìç Fragmentgrenzen</div>
                        <div class="three-toggle" onclick="toggle3DOption(this,'animate')">‚ñ∂Ô∏è Montage abspielen</div>
                        <div class="three-toggle" onclick="toggle3DOption(this,'rotate')">üîÑ Auto-Rotation</div>
                        <div class="three-toggle" onclick="toggle3DOption(this,'underside')">üîÉ Unterseite</div>
                    </div>

                    <!-- Stats -->
                    <div class="stats-row-3d" id="stats-3d" style="display:none;">
                        <div class="stat-3d">
                            <div class="stat-3d-val" id="stat-coverage">0%</div>
                            <div class="stat-3d-lbl">Abdeckung</div>
                        </div>
                        <div class="stat-3d">
                            <div class="stat-3d-val" id="stat-fragments-placed">0</div>
                            <div class="stat-3d-lbl">Fragmente platziert</div>
                        </div>
                        <div class="stat-3d">
                            <div class="stat-3d-val" id="stat-diameter">0 mm</div>
                            <div class="stat-3d-lbl">√ò Durchmesser (est.)</div>
                        </div>
                    </div>

                    <div style="display:none;gap:8px;margin-top:16px;flex-wrap:wrap;" id="three-export-btns">
                        <button class="btn btn-secondary" onclick="export3DScreenshot()">üì∏ Screenshot</button>
                        <button class="btn btn-secondary" onclick="reset3DCamera()">üéØ Kamera zur√ºcksetzen</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: Decoration / Verzierung -->
        <div class="tab-content" id="tab-decoration">
            <h2 class="section-header">üé® <span id="deco-header-text">Verzierungsanalyse</span></h2>

            <div class="feature-explanation">
                <p>
                    <strong id="deco-explain-title">Verzierung ‚Üí Strichzeichnung:</strong>
                    <span id="deco-explain-text">W√§hlen Sie ein Fragment mit Verzierung (fig√ºrlich oder ornamental). Die Software extrahiert das Dekor automatisch als ma√üst√§bliche Strichzeichnung, die in die Scherbenansicht integriert oder separat exportiert werden kann.</span>
                </p>
            </div>

            <div id="deco-content">
                <div id="deco-empty" class="empty-state">
                    <div class="icon">üé®</div>
                    <p id="deco-empty-text">Bitte zuerst Fotos analysieren. Fragmente mit Verzierung werden automatisch erkannt.</p>
                </div>

                <div id="deco-main" style="display:none;">
                    <h4 style="margin-bottom:12px;" id="deco-select-title">Fragment mit Verzierung w√§hlen:</h4>
                    <div class="deco-select-grid" id="deco-select-grid"></div>

                    <div class="deco-params">
                        <div class="slider-group">
                            <div class="slider-label">
                                <span id="lbl-line-thickness">Linienst√§rke</span>
                                <span id="val-line-thickness">2</span>
                            </div>
                            <input type="range" id="slider-line-thickness" min="1" max="5" value="2"
                                   oninput="document.getElementById('val-line-thickness').textContent=this.value">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span id="lbl-detail-level">Detailgrad</span>
                                <span id="val-detail-level">50</span>
                            </div>
                            <input type="range" id="slider-detail-level" min="10" max="100" value="50"
                                   oninput="document.getElementById('val-detail-level').textContent=this.value">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span id="lbl-edge-sensitivity">Kantenerkennung</span>
                                <span id="val-edge-sensitivity">50</span>
                            </div>
                            <input type="range" id="slider-edge-sensitivity" min="10" max="100" value="50"
                                   oninput="document.getElementById('val-edge-sensitivity').textContent=this.value">
                        </div>
                        <div class="form-group">
                            <label id="lbl-deco-type">Verzierungstyp</label>
                            <select id="select-deco-type">
                                <option value="auto">Automatisch</option>
                                <option value="figural">Fig√ºrlich</option>
                                <option value="ornamental">Ornamental/Geometrisch</option>
                                <option value="band">Banddekor</option>
                                <option value="painted">Bemalt</option>
                                <option value="incised">Ritzdekor/Eingeritzt</option>
                                <option value="stamped">Stempel/Relief</option>
                            </select>
                        </div>
                    </div>

                    <button class="btn btn-primary btn-full" onclick="runDecoExtraction()" id="btn-extract-deco">
                        üé® <span id="txt-extract-deco">Strichzeichnung extrahieren</span>
                    </button>

                    <div id="deco-result" style="display:none;margin-top:20px;">
                        <div class="deco-viewer">
                            <div class="deco-panel">
                                <h4 id="deco-original-title">üì∏ Original</h4>
                                <canvas id="deco-canvas-original" width="400" height="400"></canvas>
                            </div>
                            <div class="deco-panel line-drawing">
                                <h4 id="deco-line-title">‚úèÔ∏è Strichzeichnung (ma√üst√§blich)</h4>
                                <canvas id="deco-canvas-lineart" width="400" height="400"></canvas>
                                <div style="display:flex;gap:8px;margin-top:8px;align-items:center;">
                                    <span class="scale-badge" id="deco-scale-info">1:1</span>
                                    <span style="font-size:11px;color:var(--text-muted);" id="deco-dimensions"></span>
                                </div>
                            </div>
                        </div>

                        <div style="margin-top:16px;">
                            <h4 style="margin-bottom:8px;" id="deco-overlay-title">√úberlagerung</h4>
                            <div class="deco-panel">
                                <canvas id="deco-canvas-overlay" width="400" height="400"></canvas>
                                <div class="deco-controls">
                                    <div class="deco-overlay-toggle active" onclick="toggleOverlayMode(this,'lines')" id="toggle-lines-on-photo">
                                        ‚úèÔ∏è <span>Linien auf Foto</span>
                                    </div>
                                    <div class="deco-overlay-toggle" onclick="toggleOverlayMode(this,'photo')" id="toggle-photo-on-lines">
                                        üì∏ <span>Foto auf Zeichnung</span>
                                    </div>
                                    <div class="slider-group" style="flex:1;min-width:120px;">
                                        <div class="slider-label">
                                            <span>Transparenz</span>
                                            <span id="val-overlay-opacity">50</span>%
                                        </div>
                                        <input type="range" id="slider-overlay-opacity" min="0" max="100" value="50"
                                               oninput="document.getElementById('val-overlay-opacity').textContent=this.value;updateDecoOverlay();">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div style="display:flex;gap:8px;margin-top:16px;flex-wrap:wrap;">
                            <button class="btn btn-secondary" onclick="downloadDecoImage('lineart')">
                                üì• <span id="txt-dl-lineart">Strichzeichnung (PNG)</span>
                            </button>
                            <button class="btn btn-secondary" onclick="downloadDecoImage('overlay')">
                                üì• <span id="txt-dl-overlay">√úberlagerung (PNG)</span>
                            </button>
                            <button class="btn btn-secondary" onclick="downloadDecoSVG()">
                                üì• <span id="txt-dl-svg">Vektorgrafik (SVG)</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: Culture Period / Kulturstufe -->
        <div class="tab-content" id="tab-culture">
            <h2 class="section-header">üèõÔ∏è <span id="culture-header-text">Kulturstufen-Klassifikation</span></h2>

            <div class="feature-explanation">
                <p>
                    <strong id="culture-explain-title">Arch√§ologische Einordnung:</strong>
                    <span id="culture-explain-text">Basierend auf Materialeigenschaften, Farbgebung, Wandst√§rke, Oberfl√§chenbehandlung und Verzierungsmerkmalen schl√§gt ShardMind eine Zuordnung zu arch√§ologischen Kulturstufen vor. Die Klassifikation dient als Orientierungshilfe ‚Äî die endg√ºltige Bestimmung erfordert arch√§ologische Fachkenntnisse.</span>
                </p>
            </div>

            <div class="culture-select-wrapper">
                <label style="font-size:13px;color:var(--text-secondary);font-weight:500;" id="culture-manual-label">
                    Manuelle Zuordnung (optional ‚Äî √ºberschreibt automatische Klassifikation):
                </label>
                <div class="culture-manual-select" id="culture-chips">
                    <div class="culture-chip" data-culture="neolithic" onclick="toggleCultureChip(this)">ü™® Neolithikum</div>
                    <div class="culture-chip" data-culture="bronze-age" onclick="toggleCultureChip(this)">‚öîÔ∏è Bronzezeit</div>
                    <div class="culture-chip" data-culture="iron-age" onclick="toggleCultureChip(this)">üó°Ô∏è Eisenzeit</div>
                    <div class="culture-chip" data-culture="roman" onclick="toggleCultureChip(this)">üèõÔ∏è R√∂misch</div>
                    <div class="culture-chip" data-culture="medieval" onclick="toggleCultureChip(this)">üè∞ Mittelalter</div>
                    <div class="culture-chip" data-culture="early-modern" onclick="toggleCultureChip(this)">‚öôÔ∏è Fr√ºhe Neuzeit</div>
                    <div class="culture-chip" data-culture="modern" onclick="toggleCultureChip(this)">üè≠ Neuzeit</div>
                </div>
            </div>

            <button class="btn btn-primary" onclick="runCultureClassification()" id="btn-classify-culture" style="margin-bottom:20px;">
                üèõÔ∏è <span id="txt-classify">Kulturstufen analysieren</span>
            </button>

            <div id="culture-results"></div>

            <div id="culture-empty" class="empty-state">
                <div class="icon">üèõÔ∏è</div>
                <p id="culture-empty-text">Fragmente analysieren, um automatische Kulturzuordnung zu erhalten</p>
            </div>

            <hr style="border-color:var(--border);margin:24px 0;">

            <div id="culture-knowledge-base">
                <h3 style="font-size:18px;margin-bottom:16px;color:var(--accent);" id="culture-kb-title">üìö Keramik-Wissensbasis</h3>
                <p style="font-size:13px;color:var(--text-muted);margin-bottom:16px;" id="culture-kb-desc">
                    Merkmale verschiedener Kulturstufen, die f√ºr die Klassifikation herangezogen werden:
                </p>
                <div id="culture-kb-content"></div>
            </div>
        </div>

        <!-- TAB: Database -->

        <div class="tab-content" id="tab-database">
            <h2 class="section-header" id="database-header">Meine Sammlung</h2>
            <div id="database-content">
                <div class="empty-state">
                    <div class="icon">üíæ</div>
                    <p id="database-empty-text">Noch leer</p>
                </div>
            </div>
        </div>

        <!-- TAB: Labels -->
        <div class="tab-content" id="tab-labels">
            <h2 class="section-header" id="labels-header">Etiketten erstellen</h2>
            <div id="labels-content">
                <div class="label-options" id="label-source-options">
                    <div class="label-option active" onclick="selectLabelSource('session')" id="lbl-opt-session">Aktuelle Analyse</div>
                    <div class="label-option" onclick="selectLabelSource('database')" id="lbl-opt-database">Datenbank</div>
                    <div class="label-option" onclick="selectLabelSource('custom')" id="lbl-opt-custom">Eigenes Etikett</div>
                </div>

                <div id="label-session-content"></div>
                <div id="label-database-content" style="display:none;"></div>
                <div id="label-custom-content" style="display:none;">
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px;">
                        <div class="form-group">
                            <label>ID</label>
                            <input type="text" id="custom-label-id" placeholder="SM-CUSTOM01">
                        </div>
                        <div class="form-group">
                            <label id="lbl-custom-name">Bezeichnung</label>
                            <input type="text" id="custom-label-name">
                        </div>
                        <div class="form-group">
                            <label id="lbl-custom-desc">Beschreibung</label>
                            <input type="text" id="custom-label-desc">
                        </div>
                        <div class="form-group">
                            <label id="lbl-custom-proj">Projekt</label>
                            <input type="text" id="custom-label-proj" value="Project_2025">
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="addCustomLabel()">‚ûï <span id="txt-add-custom">Hinzuf√ºgen</span></button>
                    <div class="custom-labels-list" id="custom-labels-list"></div>
                </div>

                <hr style="border-color:var(--border);margin:20px 0;">
                <div id="label-preview-area"></div>
                <button class="btn btn-primary btn-full" onclick="createLabelsPDF()" id="btn-create-pdf" style="margin-top:16px;">
                    üìÑ <span id="txt-create-pdf">PDF erstellen</span>
                </button>
            </div>
        </div>

        <!-- TAB: Changelog -->
        <div class="tab-content" id="tab-changelog">
            <h2 class="section-header">üìã <span id="changelog-header-text">Versionshistorie</span></h2>
            <div id="changelog-content"></div>
        </div>

        <!-- TAB: Privacy -->
        <div class="tab-content" id="tab-privacy">
            <h2 class="section-header">üîí <span id="privacy-header-text">Datenschutz</span></h2>

            <div style="margin-bottom:24px;">
                <h3 style="font-size:16px;margin-bottom:12px;" id="cookie-settings-title">üç™ Cookie-Einstellungen</h3>
                <div style="display:flex;gap:24px;flex-wrap:wrap;margin-bottom:12px;">
                    <div>
                        <strong id="priv-necessary-title">Notwendige Cookies</strong>
                        <p style="font-size:12px;color:var(--text-muted);" id="priv-necessary-desc">Erforderlich f√ºr Grundfunktionen</p>
                        <input type="checkbox" checked disabled> <span style="font-size:12px;color:var(--text-muted);">Always on</span>
                    </div>
                    <div>
                        <strong id="priv-functional-title">Funktionale Cookies</strong>
                        <p style="font-size:12px;color:var(--text-muted);" id="priv-functional-desc">Einstellungen speichern</p>
                        <input type="checkbox" checked id="priv-func-checkbox">
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="saveCookieSettings()">üíæ <span id="txt-save-cookies">Einstellungen speichern</span></button>
            </div>

            <hr style="border-color:var(--border);margin:24px 0;">

            <div class="privacy-content" id="privacy-policy-content"></div>

            <hr style="border-color:var(--border);margin:24px 0;">

            <h3 style="font-size:16px;margin-bottom:12px;" id="priv-settings-title">üîí Datenschutz-Einstellungen</h3>
            <div style="display:flex;gap:12px;flex-wrap:wrap;">
                <button class="btn btn-secondary" onclick="exportUserData()">üì• <span id="txt-export">Meine Daten exportieren</span></button>
                <button class="btn btn-danger" onclick="showDeleteAccountModal()">üóëÔ∏è <span id="txt-delete">Account l√∂schen</span></button>
            </div>
            <div id="export-data-output" style="margin-top:16px;"></div>
        </div>

        <!-- TAB: Help -->
        <div class="tab-content" id="tab-help">
            <h2 class="section-header">‚ùì <span id="help-header-text">Anleitung</span></h2>
            <div class="help-content" id="help-content-area"></div>
        </div>
    </div>
</div>

<!-- ======================= DELETE ACCOUNT MODAL ======================= -->
<div class="modal-overlay" id="delete-modal">
    <div class="modal">
        <h3 id="delete-modal-title">üóëÔ∏è Account l√∂schen</h3>
        <p style="color:var(--text-secondary);margin-bottom:20px;" id="delete-modal-text">
            Sind Sie sicher? Dies kann nicht r√ºckg√§ngig gemacht werden!
        </p>
        <div style="display:flex;gap:12px;">
            <button class="btn btn-danger" onclick="confirmDeleteAccount()">‚ùå <span id="txt-confirm-delete">Ja, l√∂schen</span></button>
            <button class="btn btn-secondary" onclick="hideDeleteAccountModal()">Abbrechen</button>
        </div>
    </div>
</div>

<!-- ======================= JAVASCRIPT ======================= -->
<script>
// ==================================================
// STATE & CONFIG
// ==================================================
const APP_VERSION = "2.0";
const BASE_URL = "https://shardmind.streamlit.app";

let currentLang = 'de';
let currentUser = null;
let activePieces = [];
let clusterLabels = [];
let clusterNames = {};
let customLabels = [];
let uploadedFiles = [];
let reconImage = null;
let reconMatches = [];
let pyReady = false;

// ==================================================
// TRANSLATIONS
// ==================================================
const TRANSLATIONS = {
    de: {
        app_tagline: 'Analysiere und rekonstruiere zerbrochene Objekte',
        login_tagline: 'Arch√§ologische Fragmentanalyse & Rekonstruktion',
        login: 'Anmelden', register: 'Registrieren',
        username: 'Benutzername', password: 'Passwort',
        password_confirm: 'Passwort best√§tigen',
        login_btn: 'üîê Anmelden', register_btn: 'üìù Registrieren',
        login_error: 'Falsche Anmeldedaten',
        register_success: 'Registrierung erfolgreich!',
        register_error_exists: 'Benutzername bereits vergeben',
        register_error_password: 'Passw√∂rter stimmen nicht √ºberein',
        register_error_short: 'Passwort mind. 4 Zeichen',
        account_info: '‚ÑπÔ∏è Dein Account wird im Browser gespeichert',
        upload_title: 'üì§ FOTOS HOCHLADEN',
        upload_label: 'JPG, PNG ‚Äî Scherben auf hellem Hintergrund',
        min_size: 'Min. Fragmentgr√∂√üe', cluster_sens: 'Gruppierungsst√§rke',
        separation: 'Trennungs-Empfindlichkeit',
        detection_mode: 'Erkennungsmodus', project: 'Projekt/Grabung',
        analyze: 'Analysieren', clear: 'Leeren',
        fragments: 'Fragmente', groups: 'Gruppen',
        tab_start: 'Start', tab_gallery: 'Galerie', tab_groups: 'Gruppen',
        tab_reconstruction: 'Rekonstruktion', tab_database: 'Datenbank',
        tab_labels: 'Etiketten', tab_changelog: 'Changelog',
        tab_privacy: 'Datenschutz', tab_help: 'Hilfe',
        gallery_header: 'Erkannte Fragmente',
        groups_header: 'Gruppierung', group_name: 'Gruppenname',
        save: 'Speichern', saved: 'Gespeichert!', pieces: 'Teile',
        reconstruction_header: 'Rekonstruktion',
        select_group: 'Gruppe w√§hlen', canvas_size: 'Gr√∂√üe',
        reconstruct: 'Zusammensetzen', connections: 'Verbindungen',
        export_img: 'Bild speichern', edge_matches: 'Kantenpassungen',
        database_header: 'Meine Sammlung', db_empty: 'Noch leer',
        labels_header: 'Etiketten erstellen',
        label_session: 'Aktuelle Analyse', label_database: 'Datenbank',
        label_custom: 'Eigenes Etikett', custom_name: 'Bezeichnung',
        custom_desc: 'Beschreibung', add_custom: 'Hinzuf√ºgen',
        create_pdf: 'PDF erstellen', clear_custom: 'Liste leeren',
        search_title: 'Fragment suchen', search_found: 'Gefunden!',
        search_not_found: 'Nicht gefunden',
        demo_title: 'Demo', demo_pottery: 'Keramik', demo_plate: 'Teller',
        demo_download: 'Download',
        demo_hint: 'Herunterladen ‚Üí Links hochladen ‚Üí Analysieren',
        changelog_title: 'Versionshistorie', changelog_current: 'Aktuelle Version',
        changelog_features: 'Neue Funktionen', changelog_fixes: 'Fehlerbehebungen',
        cookie_banner_title: 'üç™ Wir verwenden Cookies',
        cookie_banner_text: 'Diese App verwendet Cookies f√ºr die Funktionalit√§t und zum Speichern Ihrer Einstellungen.',
        cookie_necessary: 'Notwendige Cookies', cookie_functional: 'Funktionale Cookies',
        accept_all: '‚úÖ Alle akzeptieren', accept_necessary: '‚öôÔ∏è Nur notwendige',
        cookie_settings: 'Cookie-Einstellungen', save_cookies: 'Einstellungen speichern',
        privacy_title: 'Datenschutzerkl√§rung', privacy_settings: 'Datenschutz-Einstellungen',
        export_data: 'Meine Daten exportieren', delete_account: 'Account l√∂schen',
        delete_confirm: 'Sind Sie sicher? Dies kann nicht r√ºckg√§ngig gemacht werden!',
        confirm_delete: 'Ja, l√∂schen',
        help_title: 'Anleitung', upload_first: 'Bitte zuerst Fotos hochladen',
        analyzing: 'Analysiere...', success_fragments: 'Fragmente erkannt!',
        porcelain: 'Porzellan/Keramik', auto: 'Automatisch',
        light_bg: 'Heller Hintergrund', dark_bg: 'Dunkler Hintergrund',
        high_contrast: 'Hoher Kontrast',
        necessary_desc: 'Erforderlich f√ºr Grundfunktionen',
        functional_desc: 'Einstellungen speichern',
        // Decoration
        tab_decoration: 'Verzierung', tab_culture: 'Kulturstufe',
        deco_header: 'Verzierungsanalyse',
        deco_explain: 'W√§hlen Sie ein Fragment mit Verzierung (fig√ºrlich oder ornamental). Die Software extrahiert das Dekor automatisch als ma√üst√§bliche Strichzeichnung.',
        deco_select: 'Fragment mit Verzierung w√§hlen:',
        deco_extract: 'Strichzeichnung extrahieren',
        deco_original: 'üì∏ Original', deco_lineart: '‚úèÔ∏è Strichzeichnung (ma√üst√§blich)',
        deco_overlay: '√úberlagerung',
        deco_empty: 'Bitte zuerst Fotos analysieren. Fragmente mit Verzierung werden automatisch erkannt.',
        deco_type: 'Verzierungstyp',
        deco_type_auto: 'Automatisch', deco_type_figural: 'Fig√ºrlich',
        deco_type_ornamental: 'Ornamental/Geometrisch', deco_type_band: 'Banddekor',
        deco_type_painted: 'Bemalt', deco_type_incised: 'Ritzdekor/Eingeritzt',
        deco_type_stamped: 'Stempel/Relief',
        line_thickness: 'Linienst√§rke', detail_level: 'Detailgrad',
        edge_sensitivity: 'Kantenerkennung',
        dl_lineart: 'Strichzeichnung (PNG)', dl_overlay: '√úberlagerung (PNG)',
        dl_svg: 'Vektorgrafik (SVG)',
        lines_on_photo: 'Linien auf Foto', photo_on_lines: 'Foto auf Zeichnung',
        // Culture
        culture_header: 'Kulturstufen-Klassifikation',
        culture_explain: 'Basierend auf Materialeigenschaften, Farbgebung, Wandst√§rke und Verzierung schl√§gt ShardMind eine Zuordnung zu Kulturstufen vor. Die endg√ºltige Bestimmung erfordert arch√§ologische Fachkenntnisse.',
        culture_manual: 'Manuelle Zuordnung (optional ‚Äî √ºberschreibt automatische Klassifikation):',
        culture_classify: 'Kulturstufen analysieren',
        culture_empty: 'Fragmente analysieren, um automatische Kulturzuordnung zu erhalten',
        culture_kb_title: 'üìö Keramik-Wissensbasis',
        culture_kb_desc: 'Merkmale verschiedener Kulturstufen, die f√ºr die Klassifikation herangezogen werden:',
        culture_confidence: 'Konfidenz', culture_criteria_used: 'Herangezogene Merkmale',
        culture_wall_thickness: 'Wandst√§rke', culture_surface: 'Oberfl√§che',
        culture_firing: 'Brandf√ºhrung', culture_temper: 'Magerung',
        culture_decoration: 'Verzierung', culture_typical_forms: 'Typische Formen',
    },
    en: {
        app_tagline: 'Analyze and reconstruct broken objects',
        login_tagline: 'Archaeological Fragment Analysis & Reconstruction',
        login: 'Login', register: 'Register',
        username: 'Username', password: 'Password',
        password_confirm: 'Confirm Password',
        login_btn: 'üîê Login', register_btn: 'üìù Register',
        login_error: 'Invalid credentials',
        register_success: 'Registration successful!',
        register_error_exists: 'Username already taken',
        register_error_password: 'Passwords do not match',
        register_error_short: 'Password min. 4 characters',
        account_info: '‚ÑπÔ∏è Your account is saved in the browser',
        upload_title: 'üì§ UPLOAD PHOTOS',
        upload_label: 'JPG, PNG ‚Äî Fragments on light background',
        min_size: 'Min. Fragment Size', cluster_sens: 'Grouping Strength',
        separation: 'Separation Sensitivity',
        detection_mode: 'Detection Mode', project: 'Project/Excavation',
        analyze: 'Analyze', clear: 'Clear',
        fragments: 'Fragments', groups: 'Groups',
        tab_start: 'Start', tab_gallery: 'Gallery', tab_groups: 'Groups',
        tab_reconstruction: 'Reconstruction', tab_database: 'Database',
        tab_labels: 'Labels', tab_changelog: 'Changelog',
        tab_privacy: 'Privacy', tab_help: 'Help',
        gallery_header: 'Detected Fragments',
        groups_header: 'Grouping', group_name: 'Group Name',
        save: 'Save', saved: 'Saved!', pieces: 'pieces',
        reconstruction_header: 'Reconstruction',
        select_group: 'Select Group', canvas_size: 'Size',
        reconstruct: 'Reconstruct', connections: 'Connections',
        export_img: 'Save Image', edge_matches: 'Edge Matches',
        database_header: 'My Collection', db_empty: 'Empty',
        labels_header: 'Create Labels',
        label_session: 'Current Analysis', label_database: 'Database',
        label_custom: 'Custom Label', custom_name: 'Name',
        custom_desc: 'Description', add_custom: 'Add',
        create_pdf: 'Create PDF', clear_custom: 'Clear List',
        search_title: 'Search Fragment', search_found: 'Found!',
        search_not_found: 'Not found',
        demo_title: 'Demo', demo_pottery: 'Pottery', demo_plate: 'Plate',
        demo_download: 'Download',
        demo_hint: 'Download ‚Üí Upload left ‚Üí Analyze',
        changelog_title: 'Version History', changelog_current: 'Current Version',
        changelog_features: 'New Features', changelog_fixes: 'Bug Fixes',
        cookie_banner_title: 'üç™ We use Cookies',
        cookie_banner_text: 'This app uses cookies for functionality and to save your settings.',
        cookie_necessary: 'Necessary Cookies', cookie_functional: 'Functional Cookies',
        accept_all: '‚úÖ Accept All', accept_necessary: '‚öôÔ∏è Necessary Only',
        cookie_settings: 'Cookie Settings', save_cookies: 'Save Settings',
        privacy_title: 'Privacy Policy', privacy_settings: 'Privacy Settings',
        export_data: 'Export My Data', delete_account: 'Delete Account',
        delete_confirm: 'Are you sure? This cannot be undone!',
        confirm_delete: 'Yes, Delete',
        help_title: 'Guide', upload_first: 'Please upload photos first',
        analyzing: 'Analyzing...', success_fragments: 'fragments detected!',
        porcelain: 'Porcelain/Ceramic', auto: 'Automatic',
        light_bg: 'Light Background', dark_bg: 'Dark Background',
        high_contrast: 'High Contrast',
        necessary_desc: 'Required for basic functionality',
        functional_desc: 'Save your settings',
        // Decoration
        tab_decoration: 'Decoration', tab_culture: 'Culture Period',
        deco_header: 'Decoration Analysis',
        deco_explain: 'Select a fragment with decoration (figural or ornamental). The software automatically extracts the decor as a scaled line drawing.',
        deco_select: 'Select fragment with decoration:',
        deco_extract: 'Extract line drawing',
        deco_original: 'üì∏ Original', deco_lineart: '‚úèÔ∏è Line Drawing (to scale)',
        deco_overlay: 'Overlay',
        deco_empty: 'Please analyze photos first. Decorated fragments will be detected automatically.',
        deco_type: 'Decoration type',
        deco_type_auto: 'Automatic', deco_type_figural: 'Figural',
        deco_type_ornamental: 'Ornamental/Geometric', deco_type_band: 'Band decoration',
        deco_type_painted: 'Painted', deco_type_incised: 'Incised',
        deco_type_stamped: 'Stamped/Relief',
        line_thickness: 'Line thickness', detail_level: 'Detail level',
        edge_sensitivity: 'Edge sensitivity',
        dl_lineart: 'Line drawing (PNG)', dl_overlay: 'Overlay (PNG)',
        dl_svg: 'Vector (SVG)',
        lines_on_photo: 'Lines on photo', photo_on_lines: 'Photo on drawing',
        // Culture
        culture_header: 'Culture Period Classification',
        culture_explain: 'Based on material properties, coloring, wall thickness, and decoration, ShardMind suggests a cultural period. Final determination requires archaeological expertise.',
        culture_manual: 'Manual assignment (optional ‚Äî overrides automatic classification):',
        culture_classify: 'Analyze culture periods',
        culture_empty: 'Analyze fragments to get automatic culture classification',
        culture_kb_title: 'üìö Ceramic Knowledge Base',
        culture_kb_desc: 'Characteristics of different culture periods used for classification:',
        culture_confidence: 'Confidence', culture_criteria_used: 'Criteria Used',
        culture_wall_thickness: 'Wall Thickness', culture_surface: 'Surface',
        culture_firing: 'Firing', culture_temper: 'Temper',
        culture_decoration: 'Decoration', culture_typical_forms: 'Typical Forms',
    }
};

function T(key) { return (TRANSLATIONS[currentLang] || TRANSLATIONS.de)[key] || key; }

// ==================================================
// CHANGELOG DATA
// ==================================================
const CHANGELOG = {
    '2.0': { date: '2025-02-07', title: 'Verzierungsanalyse, Kulturstufen & 3D-Rekonstruktion', features: [
        'üîÆ 3D-REKONSTRUKTION: Interaktives 3D-Tellermodell mit Three.js WebGL-Rendering',
        'üçΩÔ∏è GEF√ÑSSTYPEN: Flachteller, Suppenteller, Sch√ºssel, Tasse ‚Äî parametrisch anpassbar',
        'üìê PROFILGENERATOR: Tiefe, Randwinkel, Standfu√ü, Wandst√§rke einstellbar',
        'üé¨ MONTAGE-ANIMATION: Fragmente werden animiert auf den Teller projiziert',
        'üñ±Ô∏è INTERAKTIVE 3D-ANSICHT: Drehen, Zoomen, Schwenken mit Maus und Touch',
        'üé® VERZIERUNG ‚Üí STRICHZEICHNUNG: Automatische Extraktion von Dekoren als ma√üst√§bliche Linienzeichnung',
        'üèõÔ∏è KULTURSTUFEN-KLASSIFIKATION: Automatische Einordnung in arch√§ologische Epochen',
        'üìö KERAMIK-WISSENSBASIS: Neolithikum bis Neuzeit mit Bestimmungsmerkmalen',
        '‚úèÔ∏è SVG-EXPORT: Vektorgrafik-Export der Strichzeichnungen',
        'üîç √úBERLAGERUNGS-ANSICHT: Original und Zeichnung √ºberlagert',
    ], fixes: ['Verbesserte Verzierungserkennung', 'Kulturperioden-spezifische Farbanalyse', 'UV-Mapping f√ºr korrekte Texturprojektion'] },
    '1.9': { date: '2025-01-23', title: 'Datenschutz & Cookie-Consent', features: [
        'üç™ COOKIE-BANNER mit Zustimmungs-Dialog', 'üìú DATENSCHUTZERKL√ÑRUNG (DSGVO-konform)',
        'üîí Cookie-Einstellungen jederzeit √§nderbar', 'üìÑ VERBESSERTE PDF-ETIKETTEN',
        'üåç Datenschutz in DE und EN'
    ], fixes: ['PDF-Layout komplett √ºberarbeitet', 'Bessere Lesbarkeit der Etiketten'] },
    '1.8': { date: '2025-01-23', title: 'Verbesserte Fragment-Trennung', features: [
        'üî™ WATERSHED-ALGORITHMUS f√ºr Schatten-Trennung', 'üîç Bessere Erkennung von zusammenh√§ngenden Fragmenten',
        'üìê Konvexit√§ts-Defekte zur Fragment-Trennung', 'üéØ Verbesserte Morphologie-Operationen',
        'üìã NEUER CHANGELOG-TAB', 'üõ†Ô∏è Einstellbare Trennungs-Empfindlichkeit'
    ], fixes: ['Fragmente die durch Schatten verbunden waren werden jetzt getrennt'] },
    '1.7': { date: '2025-01-21', title: 'Kreis-Fitting Rekonstruktion', features: [
        'üéØ KOMPLETT NEUER REKONSTRUKTIONS-ALGORITHMUS', 'üìä Kreis-Fitting aus blauem Dekorband',
        'üî¨ Muster-Analyse mit pattern_direction Erkennung', 'üìö Vollst√§ndige Algorithmus-Dokumentation'
    ], fixes: ['Funktioniert auch bei Schatten-Verbindungen'] },
    '1.5': { date: '2025-01-21', title: 'Echte Kantenpassung', features: [
        'üß© KOMPLETT NEUE REKONSTRUKTION mit echter Kantenpassung', 'üìê Kontur-basierte Kantenanalyse',
        'üìÑ PDF-Layout √ºberarbeitet (3x4 Raster auf A4)'
    ], fixes: ['Iteratives Zusammensetzen der Fragmente'] },
    '1.4': { date: '2025-01-21', title: 'Gemini & Accounts', features: [
        'ü§ñ Gemini API Integration', 'üíæ Dauerhafte Account-Speicherung',
        'üåç Verbesserte √úbersetzungen', 'üè∑Ô∏è Eigene Etiketten'
    ], fixes: ['Android Bild-Bug behoben'] },
    '1.3': { date: '2025-01-21', title: 'Start-Tab & QR-Codes', features: [
        'üè† Start-Tab mit Demo-Bildern', 'üè∑Ô∏è PDF-Etiketten mit QR-Codes', 'üìä Verbessertes Clustering'
    ], fixes: [] },
    '1.2': { date: '2025-01-16', title: 'Login & Clustering', features: [
        'üîê Login-System', 'üß© Kanten-basiertes Clustering', 'üìñ Hilfe-Tab', 'üåç Zweisprachig'
    ], fixes: [] },
    '1.1': { date: '2025-01-15', title: 'Erste Rekonstruktion', features: [
        'üß© Erste Rekonstruktions-Funktion', 'üì¶ Gruppierung nach Farbe/Material'
    ], fixes: [] },
    '1.0': { date: '2025-01-14', title: 'Erste Version', features: [
        'üè∫ Erste Version', 'üî¨ Grundlegende Segmentierung', 'üé® Farbanalyse'
    ], fixes: [] },
};

// ==================================================
// PRIVACY POLICIES
// ==================================================
const PRIVACY_DE = `<h2>Datenschutzerkl√§rung</h2><p><strong>Stand: Januar 2025</strong></p>
<h3>1. Verantwortlicher</h3><p>Verantwortlich f√ºr die Datenverarbeitung ist der Betreiber von ShardMind.</p>
<h3>2. Welche Daten wir erheben</h3>
<h3>2.1 Account-Daten</h3><p>Benutzername, Passwort (als Hash), Erstellungsdatum.</p>
<h3>2.2 Nutzungsdaten</h3><p>Bilder (nur w√§hrend der Sitzung), analysierte Fragmente, Gruppen.</p>
<h3>2.3 Cookies</h3><p>Notwendige Cookies (Session), Funktionale Cookies (Einstellungen).</p>
<h3>3. Zweck</h3><p>App-Funktionalit√§t, Speicherung, Verbesserung der Erfahrung.</p>
<h3>4. Datenweitergabe</h3><p>Keine Weitergabe an Dritte.</p>
<h3>5. Ihre Rechte (DSGVO)</h3><p>Auskunft, Berichtigung, L√∂schung, Widerspruch.</p>
<h3>6. Kontakt</h3><p>Bei Fragen kontaktieren Sie uns √ºber die App.</p>`;

const PRIVACY_EN = `<h2>Privacy Policy</h2><p><strong>Last updated: January 2025</strong></p>
<h3>1. Data Controller</h3><p>The operator of ShardMind is responsible for data processing.</p>
<h3>2. Data We Collect</h3>
<h3>2.1 Account Data</h3><p>Username, password (stored as hash), creation date.</p>
<h3>2.2 Usage Data</h3><p>Images (session only), analyzed fragments, groups.</p>
<h3>2.3 Cookies</h3><p>Necessary cookies (session), Functional cookies (settings).</p>
<h3>3. Purpose</h3><p>App functionality, storage, improving experience.</p>
<h3>4. Data Sharing</h3><p>No sharing with third parties.</p>
<h3>5. Your Rights (GDPR)</h3><p>Access, rectification, erasure, objection.</p>
<h3>6. Contact</h3><p>Contact us through the app.</p>`;

const HELP_DE = `<h2>Schnellstart</h2>
<ul><li><strong>Demo testen</strong>: Testbild im Start-Tab herunterladen</li>
<li><strong>Hochladen</strong>: Bild in den Upload-Bereich ziehen</li>
<li><strong>Analysieren</strong>: "üî¨ Analysieren" klicken</li>
<li><strong>Rekonstruieren</strong>: Gruppe w√§hlen ‚Üí "üß© Zusammensetzen"</li></ul>
<h2>Tipps</h2><ul><li><strong>Heller Hintergrund</strong> funktioniert am besten</li>
<li><strong>Nicht √ºberlappen</strong> lassen</li>
<li><strong>Gute Beleuchtung</strong> ohne Schatten</li>
<li>Bei Problemen: Erkennungsmodus √§ndern</li></ul>
<h2>üîÆ 3D-Rekonstruktion (NEU in v2.0)</h2>
<p>Im Rekonstruktions-Tab wechseln Sie zwischen <strong>2D</strong> und <strong>3D-Ansicht</strong>:</p>
<ul><li><strong>Gef√§√ütypen</strong>: Flachteller, Suppenteller, Sch√ºssel, Tasse</li>
<li><strong>Parameter</strong>: Tiefe, Randwinkel, Standfu√ü und Wandst√§rke anpassbar</li>
<li><strong>Interaktiv</strong>: Drehen (Maus ziehen), Zoomen (Scrollen), Verschieben (Rechtsklick)</li>
<li><strong>Montage-Animation</strong>: Fragmente werden animiert auf den Teller projiziert</li>
<li><strong>Optionen</strong>: Drahtgitter, Fragmentgrenzen, Auto-Rotation, Unterseite</li>
<li><strong>Export</strong>: Screenshot als PNG speichern</li></ul>
<p><strong>So funktioniert es:</strong> Die Software nutzt das Circle-Fitting der Dekorb√§nder, um den Tellerradius zu bestimmen. Daraus wird ein parametrisches 3D-Modell erzeugt (Rotationsk√∂rper). Die Fragmentfotos werden als Textur auf die Oberfl√§che projiziert. Fehlende Bereiche zeigen die "Tonfarbe" des Gef√§√ük√∂rpers.</p>
<h2>üé® Verzierungsanalyse (NEU in v2.0)</h2>
<p>Im Tab "üé® Verzierung" k√∂nnen Sie Fragmente mit Dekor ausw√§hlen und automatisch eine <strong>ma√üst√§bliche Strichzeichnung</strong> extrahieren lassen.</p>
<ul><li><strong>Verzierungstypen</strong>: Fig√ºrlich, Ornamental, Banddekor, Bemalt, Ritzdekor, Stempel/Relief</li>
<li><strong>Parameter</strong>: Linienst√§rke, Detailgrad und Kantenerkennung anpassbar</li>
<li><strong>√úberlagerung</strong>: Original und Zeichnung √ºberlagert mit Transparenzregler</li>
<li><strong>Export</strong>: PNG (Strichzeichnung), PNG (√úberlagerung), SVG (Vektorgrafik)</li></ul>
<h2>üèõÔ∏è Kulturstufen-Klassifikation (NEU in v2.0)</h2>
<p>Im Tab "üèõÔ∏è Kulturstufe" analysiert ShardMind Material, Farbe, Form und Verzierung und schl√§gt eine arch√§ologische Einordnung vor:</p>
<ul><li><strong>Neolithikum</strong>: Grobe Magerung, Ritzdekor, Kugelt√∂pfe</li>
<li><strong>Bronzezeit</strong>: Rillen, Buckel, verbesserte Brandf√ºhrung</li>
<li><strong>Eisenzeit</strong>: Graphittonware, Drehscheibe, Kammstrich</li>
<li><strong>R√∂misch</strong>: Terra Sigillata, d√ºnne Wandung, Reliefdekor</li>
<li><strong>Mittelalter</strong>: Steinzeug, Glasur, Wellenb√§nder</li>
<li><strong>Neuzeit</strong>: Porzellan, Transfer-Druck, industrielle Fertigung</li></ul>
<p><strong>Hinweis:</strong> Die automatische Klassifikation dient als Orientierungshilfe. Die endg√ºltige Bestimmung erfordert arch√§ologische Fachkenntnisse unter Ber√ºcksichtigung des Fundkontextes.</p>
<h2>Rekonstruktion</h2><p>Analysiert Fragmentkanten, findet passende Abschnitte, berechnet Rotation und setzt schrittweise zusammen.</p>
<h2>Etiketten</h2><p>PDF mit QR-Codes, eigene Etiketten, QR-Codes verlinken zur App.</p>
<h2>Datenschutz</h2><p>Datenschutzerkl√§rung, Cookie-Einstellungen, Account und Daten l√∂schen.</p>`;

const HELP_EN = `<h2>Quick Start</h2>
<ul><li><strong>Try Demo</strong>: Download test image in Start tab</li>
<li><strong>Upload</strong>: Drag image to upload area</li>
<li><strong>Analyze</strong>: Click "üî¨ Analyze"</li>
<li><strong>Reconstruct</strong>: Select group ‚Üí "üß© Reconstruct"</li></ul>
<h2>Tips</h2><ul><li><strong>Light background</strong> works best</li>
<li><strong>Don't overlap</strong> fragments</li>
<li><strong>Good lighting</strong> without shadows</li>
<li>If problems: Change detection mode</li></ul>
<h2>üîÆ 3D Reconstruction (NEW in v2.0)</h2>
<p>In the Reconstruction tab, switch between <strong>2D</strong> and <strong>3D view</strong>:</p>
<ul><li><strong>Vessel types</strong>: Flat plate, soup plate, bowl, cup</li>
<li><strong>Parameters</strong>: Depth, rim angle, foot, wall thickness adjustable</li>
<li><strong>Interactive</strong>: Rotate (drag), zoom (scroll), pan (right-click)</li>
<li><strong>Assembly animation</strong>: Fragments animated onto the plate</li>
<li><strong>Options</strong>: Wireframe, fragment boundaries, auto-rotation, underside</li>
<li><strong>Export</strong>: Save screenshot as PNG</li></ul>
<p><strong>How it works:</strong> The software uses circle fitting from decoration bands to determine plate radius. A parametric 3D model (surface of revolution) is generated. Fragment photos are projected as texture onto the surface. Missing areas show the clay body color.</p>
<h2>üé® Decoration Analysis (NEW in v2.0)</h2>
<p>In the "üé® Decoration" tab, select decorated fragments and automatically extract a <strong>scaled line drawing</strong>.</p>
<ul><li><strong>Decoration types</strong>: Figural, ornamental, band, painted, incised, stamped/relief</li>
<li><strong>Parameters</strong>: Line thickness, detail level, edge sensitivity adjustable</li>
<li><strong>Overlay</strong>: Original and drawing overlaid with transparency control</li>
<li><strong>Export</strong>: PNG (line drawing), PNG (overlay), SVG (vector)</li></ul>
<h2>üèõÔ∏è Culture Period Classification (NEW in v2.0)</h2>
<p>In the "üèõÔ∏è Culture" tab, ShardMind analyzes material, color, form and decoration to suggest an archaeological classification:</p>
<ul><li><strong>Neolithic</strong>: Coarse temper, incised decoration, globular pots</li>
<li><strong>Bronze Age</strong>: Grooves, bosses, improved firing</li>
<li><strong>Iron Age</strong>: Graphite ware, wheel-thrown, comb decoration</li>
<li><strong>Roman</strong>: Terra sigillata, thin walls, relief decoration</li>
<li><strong>Medieval</strong>: Stoneware, glaze, wavy bands</li>
<li><strong>Modern</strong>: Porcelain, transfer printing, industrial production</li></ul>
<p><strong>Note:</strong> Automatic classification serves as a guide. Final determination requires archaeological expertise considering the find context.</p>
<h2>Reconstruction</h2><p>Analyzes fragment edges, finds matching segments, calculates rotation and assembles step by step.</p>
<h2>Labels</h2><p>PDF with QR codes, custom labels, QR codes link to app.</p>
<h2>Privacy</h2><p>Privacy policy, cookie settings, delete account and data.</p>`;

// ==================================================
// UTILITY FUNCTIONS
// ==================================================
function toast(msg, type='info') {
    const c = document.getElementById('toast-container');
    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.textContent = msg;
    c.appendChild(t);
    setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 3000);
}

function hashPassword(pw) {
    // Simple hash for client-side (in production use bcrypt/server-side)
    let hash = 0;
    for (let i = 0; i < pw.length; i++) {
        const c = pw.charCodeAt(i);
        hash = ((hash << 5) - hash) + c;
        hash |= 0;
    }
    return 'smhash_' + Math.abs(hash).toString(36);
}

function genId() {
    const hex = [...Array(8)].map(() => Math.floor(Math.random()*16).toString(16)).join('').toUpperCase();
    return `SM-${hex}`;
}

function getDB() {
    try { return JSON.parse(localStorage.getItem('shardmind_db') || '{}'); } catch { return {}; }
}
function saveDB(db) { localStorage.setItem('shardmind_db', JSON.stringify(db)); }

function getUserData() {
    const db = getDB();
    if (!currentUser || !db[currentUser]) return { pieces: {}, clusters: {} };
    return db[currentUser].data || { pieces: {}, clusters: {} };
}
function saveUserData(data) {
    const db = getDB();
    if (currentUser && db[currentUser]) {
        db[currentUser].data = data;
        saveDB(db);
    }
}

// ==================================================
// AUTH
// ==================================================
function handleLogin(e) {
    e.preventDefault();
    const user = document.getElementById('login-username').value.trim();
    const pw = document.getElementById('login-password').value;
    const db = getDB();
    
    if (!db[user] || db[user].pw_hash !== hashPassword(pw)) {
        const err = document.getElementById('login-error');
        err.textContent = T('login_error');
        err.style.display = 'block';
        return false;
    }
    
    currentUser = user;
    localStorage.setItem('shardmind_user', user);
    showApp();
    return false;
}

function handleRegister(e) {
    e.preventDefault();
    const user = document.getElementById('reg-username').value.trim();
    const pw = document.getElementById('reg-password').value;
    const confirm = document.getElementById('reg-confirm').value;
    const msg = document.getElementById('register-msg');
    
    if (pw !== confirm) {
        msg.textContent = T('register_error_password');
        msg.style.color = 'var(--error)';
        msg.style.display = 'block'; return false;
    }
    if (pw.length < 4) {
        msg.textContent = T('register_error_short');
        msg.style.color = 'var(--error)';
        msg.style.display = 'block'; return false;
    }
    
    const db = getDB();
    if (db[user]) {
        msg.textContent = T('register_error_exists');
        msg.style.color = 'var(--error)';
        msg.style.display = 'block'; return false;
    }
    
    db[user] = {
        pw_hash: hashPassword(pw),
        created: new Date().toISOString(),
        data: { pieces: {}, clusters: {} }
    };
    saveDB(db);
    
    msg.textContent = T('register_success');
    msg.style.color = 'var(--success)';
    msg.style.display = 'block';
    return false;
}

function handleLogout() {
    currentUser = null;
    activePieces = [];
    clusterLabels = [];
    reconImage = null;
    localStorage.removeItem('shardmind_user');
    document.getElementById('app-page').classList.remove('active');
    document.getElementById('login-page').classList.remove('hidden');
    document.getElementById('login-page').style.display = '';
}

// ==================================================
// NAVIGATION
// ==================================================
function showLoginTab(tab) {
    document.querySelectorAll('.login-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.login-form').forEach(f => f.classList.remove('active'));
    document.querySelector(`#${tab}-form`).classList.add('active');
    event.target.classList.add('active');
}

function switchTab(name) {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.getElementById(`tab-${name}`).classList.add('active');
    event.target.closest('.tab-btn').classList.add('active');
}

function toggleMobileSidebar() {
    document.getElementById('sidebar').classList.toggle('mobile-open');
}

// ==================================================
// LANGUAGE
// ==================================================
function setLanguage(lang) {
    currentLang = lang;
    localStorage.setItem('shardmind_lang', lang);
    
    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(`lang-${lang}-btn`)?.classList.add('active');
    document.getElementById(`app-lang-${lang}`)?.classList.add('active');
    
    updateAllTranslations();
}

function updateAllTranslations() {
    // Update tab labels
    document.querySelectorAll('.tab-label').forEach(el => {
        const key = el.dataset.key;
        if (key && T(key)) el.textContent = T(key);
    });
    
    // Update specific elements
    const updates = {
        'login-tagline': T('login_tagline'),
        'start-tagline': T('app_tagline'),
        'upload-label': T('upload_label'),
        'sidebar-upload-title': T('upload_title'),
        'lbl-min-size': T('min_size'),
        'lbl-cluster-sens': T('cluster_sens'),
        'lbl-separation': T('separation'),
        'lbl-detection-mode': T('detection_mode'),
        'lbl-project': T('project'),
        'txt-analyze': T('analyze'),
        'txt-clear': T('clear'),
        'gallery-header': T('gallery_header'),
        'groups-header': T('groups_header'),
        'recon-header': T('reconstruction_header'),
        'database-header': T('database_header'),
        'labels-header': T('labels_header'),
        'changelog-header-text': T('changelog_title'),
        'privacy-header-text': T('privacy_title'),
        'help-header-text': T('help_title'),
        'gallery-empty-text': T('upload_first'),
        'search-title': T('search_title'),
        'demo-title': T('demo_title'),
        'demo-hint': T('demo_hint'),
        'demo-pottery-title': T('demo_pottery'),
        'demo-plate-title': T('demo_plate'),
        'lbl-opt-session': T('label_session'),
        'lbl-opt-database': T('label_database'),
        'lbl-opt-custom': T('label_custom'),
        'txt-create-pdf': T('create_pdf'),
        'txt-save-cookies': T('save_cookies'),
        'txt-export': T('export_data'),
        'txt-delete': T('delete_account'),
        'txt-add-custom': T('add_custom'),
        'btn-accept-all': T('accept_all'),
        'btn-accept-necessary': T('accept_necessary'),
        'cookie-title': T('cookie_banner_title'),
        'cookie-text': T('cookie_banner_text'),
        'lbl-cookie-necessary': T('cookie_necessary'),
        'lbl-cookie-functional': T('cookie_functional'),
        'tab-login-btn': T('login_btn'),
        'tab-register-btn': T('register_btn'),
        'lbl-username': T('username'),
        'lbl-password': T('password'),
        'lbl-reg-username': T('username'),
        'lbl-reg-password': T('password'),
        'lbl-reg-confirm': T('password_confirm'),
        'btn-login': T('login_btn'),
        'btn-register': T('register_btn'),
        'account-info-text': T('account_info'),
        'progress-text': T('analyzing'),
        'cookie-settings-title': T('cookie_settings'),
        'priv-necessary-title': T('cookie_necessary'),
        'priv-functional-title': T('cookie_functional'),
        'priv-necessary-desc': T('necessary_desc'),
        'priv-functional-desc': T('functional_desc'),
        'priv-settings-title': T('privacy_settings'),
        // Decoration & Culture
        'deco-header-text': T('deco_header'),
        'deco-explain-text': T('deco_explain'),
        'deco-select-title': T('deco_select'),
        'txt-extract-deco': T('deco_extract'),
        'deco-original-title': T('deco_original'),
        'deco-line-title': T('deco_lineart'),
        'deco-overlay-title': T('deco_overlay'),
        'deco-empty-text': T('deco_empty'),
        'lbl-line-thickness': T('line_thickness'),
        'lbl-detail-level': T('detail_level'),
        'lbl-edge-sensitivity': T('edge_sensitivity'),
        'lbl-deco-type': T('deco_type'),
        'txt-dl-lineart': T('dl_lineart'),
        'txt-dl-overlay': T('dl_overlay'),
        'txt-dl-svg': T('dl_svg'),
        'culture-header-text': T('culture_header'),
        'culture-explain-text': T('culture_explain'),
        'culture-manual-label': T('culture_manual'),
        'txt-classify': T('culture_classify'),
        'culture-empty-text': T('culture_empty'),
        'culture-kb-title': T('culture_kb_title'),
        'culture-kb-desc': T('culture_kb_desc'),
    };
    
    Object.entries(updates).forEach(([id, text]) => {
        const el = document.getElementById(id);
        if (el) el.textContent = text;
    });
    
    // Update mode select options
    const modeSelect = document.getElementById('select-mode');
    if (modeSelect) {
        const modes = { porcelain: T('porcelain'), auto: T('auto'), light_bg: T('light_bg'), dark_bg: T('dark_bg'), high_contrast: T('high_contrast') };
        [...modeSelect.options].forEach(opt => { if (modes[opt.value]) opt.textContent = modes[opt.value]; });
    }
    
    // Update privacy and help content
    document.getElementById('privacy-policy-content').innerHTML = currentLang === 'de' ? PRIVACY_DE : PRIVACY_EN;
    document.getElementById('help-content-area').innerHTML = currentLang === 'de' ? HELP_DE : HELP_EN;
}

// ==================================================
// COOKIE CONSENT
// ==================================================
function checkCookieConsent() {
    const consent = localStorage.getItem('shardmind_cookie_consent');
    if (!consent) {
        document.getElementById('cookie-banner').classList.add('show');
    }
}
function acceptAllCookies() {
    localStorage.setItem('shardmind_cookie_consent', JSON.stringify({ necessary: true, functional: true }));
    document.getElementById('cookie-banner').classList.remove('show');
}
function acceptNecessaryCookies() {
    localStorage.setItem('shardmind_cookie_consent', JSON.stringify({ necessary: true, functional: false }));
    document.getElementById('cookie-banner').classList.remove('show');
}
function saveCookieSettings() {
    const func = document.getElementById('priv-func-checkbox').checked;
    localStorage.setItem('shardmind_cookie_consent', JSON.stringify({ necessary: true, functional: func }));
    toast(T('saved'), 'success');
}

// ==================================================
// FILE UPLOAD
// ==================================================
const fileInput = document.getElementById('file-input');
const uploadArea = document.getElementById('upload-area');

fileInput?.addEventListener('change', (e) => {
    uploadedFiles = [...e.target.files];
    renderUploadedFiles();
});

uploadArea?.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
uploadArea?.addEventListener('dragleave', () => { uploadArea.classList.remove('dragover'); });
uploadArea?.addEventListener('drop', (e) => {
    e.preventDefault(); uploadArea.classList.remove('dragover');
    uploadedFiles = [...e.dataTransfer.files].filter(f => f.type.startsWith('image/'));
    const dt = new DataTransfer();
    uploadedFiles.forEach(f => dt.items.add(f));
    fileInput.files = dt.files;
    renderUploadedFiles();
});

function renderUploadedFiles() {
    const list = document.getElementById('upload-files-list');
    list.innerHTML = uploadedFiles.map(f =>
        `<div class="upload-file-item"><span>${f.name}</span><span>${(f.size/1024).toFixed(0)}KB</span></div>`
    ).join('');
}

// ==================================================
// DEMO IMAGES
// ==================================================
function drawDemoPottery() {
    const canvas = document.getElementById('demo-canvas-pottery');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = '#e6e6e1';
    ctx.fillRect(0, 0, w, h);
    
    const cx = w/2, cy = h/2, r = 150;
    const colors = ['#374B82','#3C5087','#32467D','#41558C','#2D4178','#465A91'];
    const num = 6;
    const angles = [];
    for (let i = 0; i < num; i++) angles.push(i * 2*Math.PI/num + (Math.random()-0.5)*0.3);
    angles.sort((a,b) => a-b);
    
    for (let i = 0; i < num; i++) {
        const a1 = angles[i];
        let a2 = angles[(i+1)%num];
        if (a2 < a1) a2 += 2*Math.PI;
        const mid = (a1+a2)/2;
        const ox = 80*Math.cos(mid) + (Math.random()-0.5)*40;
        const oy = 80*Math.sin(mid) + (Math.random()-0.5)*40;
        
        ctx.beginPath();
        ctx.moveTo(cx+ox, cy+oy);
        for (let a = a1; a <= a2; a += 0.05) {
            ctx.lineTo(cx+ox+(r+5)*Math.cos(a), cy+oy+(r+5)*Math.sin(a));
        }
        ctx.closePath();
        
        // Clip to circle
        ctx.save();
        ctx.clip();
        ctx.beginPath();
        ctx.arc(cx+ox, cy+oy, r+10, 0, 2*Math.PI);
        ctx.fillStyle = colors[i];
        ctx.fill();
        ctx.restore();
        
        // Draw piece
        ctx.beginPath();
        ctx.moveTo(cx+ox, cy+oy);
        for (let a = a1; a <= a2; a += 0.05) {
            const pr = r - 3 + Math.sin(a*5)*2;
            ctx.lineTo(cx+ox+pr*Math.cos(a), cy+oy+pr*Math.sin(a));
        }
        ctx.closePath();
        ctx.fillStyle = colors[i];
        ctx.fill();
        ctx.strokeStyle = '#2a3560';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

function drawDemoPlate() {
    const canvas = document.getElementById('demo-canvas-plate');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = '#e1e1dc';
    ctx.fillRect(0, 0, w, h);
    
    const cx = w/2, cy = h/2, outerR = 160, innerR = 30;
    const num = 5;
    const angles = [];
    for (let i = 0; i < num; i++) angles.push(i * 2*Math.PI/num + (Math.random()-0.5)*0.2);
    angles.sort((a,b) => a-b);
    
    for (let i = 0; i < num; i++) {
        const a1 = angles[i];
        let a2 = angles[(i+1)%num];
        if (a2 < a1) a2 += 2*Math.PI;
        const mid = (a1+a2)/2;
        const ox = 60*Math.cos(mid) + (Math.random()-0.5)*30;
        const oy = 60*Math.sin(mid) + (Math.random()-0.5)*30;
        
        ctx.beginPath();
        for (let a = a1; a <= a2; a += 0.04) {
            ctx.lineTo(cx+ox+innerR*Math.cos(a), cy+oy+innerR*Math.sin(a));
        }
        for (let a = a2; a >= a1; a -= 0.04) {
            ctx.lineTo(cx+ox+outerR*Math.cos(a), cy+oy+outerR*Math.sin(a));
        }
        ctx.closePath();
        ctx.fillStyle = '#FAF8F5';
        ctx.fill();
        ctx.strokeStyle = '#C8C3BE';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Rim dots
        for (let a = a1; a <= a2; a += (a2-a1)/6) {
            ctx.beginPath();
            ctx.arc(cx+ox+(outerR-15)*Math.cos(a), cy+oy+(outerR-15)*Math.sin(a), 3, 0, 2*Math.PI);
            ctx.fillStyle = '#A59B8C';
            ctx.fill();
        }
    }
}

function downloadDemoImage(type) {
    const canvas = document.getElementById(`demo-canvas-${type}`);
    if (!canvas) return;
    const link = document.createElement('a');
    link.download = `demo_${type}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// ==================================================
// SHOW APP
// ==================================================
function showApp() {
    document.getElementById('login-page').style.display = 'none';
    document.getElementById('app-page').classList.add('active');
    document.getElementById('sidebar-username').textContent = currentUser;
    
    updateAllTranslations();
    updateDBMetrics();
    renderChangelog();
    renderCultureKnowledgeBase();
    drawDemoPottery();
    drawDemoPlate();
}

function updateDBMetrics() {
    const data = getUserData();
    const pc = Object.keys(data.pieces || {}).length;
    const gc = Object.keys(data.clusters || {}).length;
    document.getElementById('db-fragments-count').textContent = pc;
    document.getElementById('db-groups-count').textContent = gc;
}

// ==================================================
// SEARCH
// ==================================================
function searchFragment() {
    const id = document.getElementById('search-input').value.trim().toUpperCase();
    if (!id) return;
    
    const result = document.getElementById('search-result');
    
    // Search in active pieces
    let found = activePieces.find(p => p.id === id);
    
    // Search in database
    if (!found) {
        const data = getUserData();
        found = data.pieces?.[id];
    }
    
    if (found) {
        result.innerHTML = `<div style="padding:12px;background:rgba(74,222,128,0.08);border:1px solid rgba(74,222,128,0.2);border-radius:var(--radius);margin-top:8px;">
            <strong style="color:var(--success);">${T('search_found')}</strong><br>
            <span style="font-family:'JetBrains Mono',monospace;color:var(--accent);">${found.id}</span><br>
            <span style="color:var(--text-secondary);">${found.name || 'Fragment'} | ${found.material || '-'}</span>
            ${found.thumbnailDataUrl ? `<br><img src="${found.thumbnailDataUrl}" style="width:80px;margin-top:8px;border-radius:6px;">` : ''}
        </div>`;
    } else {
        result.innerHTML = `<div style="padding:12px;background:rgba(248,113,113,0.08);border:1px solid rgba(248,113,113,0.2);border-radius:var(--radius);margin-top:8px;">
            <strong style="color:var(--error);">${T('search_not_found')}: ${id}</strong>
        </div>`;
    }
}

// ==================================================
// LABEL SOURCE SELECTION
// ==================================================
function selectLabelSource(source) {
    document.querySelectorAll('.label-option').forEach(o => o.classList.remove('active'));
    event.target.classList.add('active');
    
    document.getElementById('label-session-content').style.display = source === 'session' ? '' : 'none';
    document.getElementById('label-database-content').style.display = source === 'database' ? '' : 'none';
    document.getElementById('label-custom-content').style.display = source === 'custom' ? '' : 'none';
}

function addCustomLabel() {
    const id = document.getElementById('custom-label-id').value || genId();
    const name = document.getElementById('custom-label-name').value || 'Custom';
    const desc = document.getElementById('custom-label-desc').value;
    const proj = document.getElementById('custom-label-proj').value;
    
    customLabels.push({ id, name, description: desc, excavation: proj, material: '', created: new Date().toISOString() });
    renderCustomLabels();
    toast(T('saved'), 'success');
}

function renderCustomLabels() {
    const list = document.getElementById('custom-labels-list');
    if (customLabels.length === 0) { list.innerHTML = ''; return; }
    
    list.innerHTML = customLabels.map((l, i) =>
        `<div class="custom-label-item">
            <span><strong>${l.id}</strong> ‚Äî ${l.name}</span>
            <button class="btn btn-sm btn-secondary" onclick="customLabels.splice(${i},1);renderCustomLabels();">‚úï</button>
        </div>`
    ).join('') + `<button class="btn btn-sm btn-danger" style="margin-top:8px;" onclick="customLabels=[];renderCustomLabels();">üóëÔ∏è ${T('clear_custom')}</button>`;
}

// ==================================================
// GALLERY & GROUPS RENDERING
// ==================================================
const CLUSTER_COLORS = ["#E74C3C","#3498DB","#2ECC71","#F39C12","#9B59B6","#1ABC9C","#E67E22","#34495E"];

function renderGallery() {
    const container = document.getElementById('gallery-content');
    if (activePieces.length === 0) {
        container.innerHTML = `<div class="empty-state"><div class="icon">üì∑</div><p>${T('upload_first')}</p></div>`;
        return;
    }
    
    let html = '<div class="gallery-grid">';
    activePieces.forEach(p => {
        const cid = p.cluster ?? -1;
        const color = cid >= 0 ? CLUSTER_COLORS[cid % CLUSTER_COLORS.length] : '#B0B0B0';
        html += `<div class="gallery-item">
            <div class="gallery-item-border" style="background:${color};"></div>
            ${p.thumbnailDataUrl ? `<img src="${p.thumbnailDataUrl}" alt="${p.id}">` : '<div style="width:100%;aspect-ratio:1;background:var(--bg-secondary);"></div>'}
            <div class="gallery-info">
                <div class="gallery-id">${p.id.substring(0, 11)}</div>
                <div class="gallery-name">${(p.name || '').substring(0, 20)}</div>
            </div>
        </div>`;
    });
    html += '</div>';
    container.innerHTML = html;
}

function renderGroups() {
    const container = document.getElementById('groups-content');
    if (activePieces.length === 0) {
        container.innerHTML = `<div class="empty-state"><div class="icon">üì¶</div><p>${T('upload_first')}</p></div>`;
        return;
    }
    
    const clusterIds = [...new Set(activePieces.map(p => p.cluster ?? -1))].filter(c => c >= 0).sort();
    
    if (clusterIds.length === 0) {
        container.innerHTML = `<div class="empty-state"><div class="icon">üì¶</div><p>No groups</p></div>`;
        return;
    }
    
    let html = '';
    clusterIds.forEach(cid => {
        const cp = activePieces.filter(p => p.cluster === cid);
        const mats = cp.map(p => p.material || 'Unknown');
        const common = mode(mats);
        const name = clusterNames[cid] || `${common}_Gruppe_${cid + 1}`;
        const color = CLUSTER_COLORS[cid % CLUSTER_COLORS.length];
        
        html += `<div class="group-card" style="border-left:4px solid ${color};">
            <div class="group-header">
                <div>
                    <input type="text" value="${name}" onchange="clusterNames[${cid}]=this.value" 
                           style="background:transparent;border:none;color:var(--text-primary);font-size:18px;font-weight:600;width:250px;">
                </div>
                <span class="group-badge">${cp.length} ${T('pieces')}</span>
            </div>
            <div class="group-pieces">
                ${cp.slice(0, 8).map(p => `<div class="group-piece">
                    ${p.thumbnailDataUrl ? `<img src="${p.thumbnailDataUrl}">` : '<div style="width:80px;height:80px;background:var(--bg-secondary);"></div>'}
                </div>`).join('')}
            </div>
            <div class="group-actions">
                <button class="btn btn-sm btn-primary" onclick="saveGroupToDB(${cid})">üíæ ${T('save')}</button>
            </div>
        </div>`;
    });
    container.innerHTML = html;
}

function mode(arr) {
    const freq = {};
    arr.forEach(v => freq[v] = (freq[v]||0) + 1);
    return Object.entries(freq).sort((a,b) => b[1]-a[1])[0]?.[0] || 'Unknown';
}

function saveGroupToDB(cid) {
    const data = getUserData();
    const cp = activePieces.filter(p => p.cluster === cid);
    const name = clusterNames[cid] || `Group_${cid+1}`;
    const key = `${name}_${Date.now()}`;
    
    data.clusters[key] = {
        name, created: new Date().toISOString(),
        piece_ids: cp.map(p => p.id)
    };
    
    cp.forEach(p => {
        const saved = { ...p };
        delete saved.imageData;  // Don't store raw image data
        data.pieces[p.id] = saved;
    });
    
    saveUserData(data);
    updateDBMetrics();
    toast(T('saved'), 'success');
}

function renderDatabase() {
    const container = document.getElementById('database-content');
    const data = getUserData();
    const pieces = data.pieces || {};
    const clusters = data.clusters || {};
    
    if (Object.keys(pieces).length === 0) {
        container.innerHTML = `<div class="empty-state"><div class="icon">üíæ</div><p>${T('db_empty')}</p></div>`;
        return;
    }
    
    let html = `<p style="color:var(--text-secondary);margin-bottom:16px;"><strong>${Object.keys(pieces).length} ${T('fragments')}</strong></p>`;
    html += '<div class="db-grid">';
    Object.entries(pieces).slice(0, 24).forEach(([pid, p]) => {
        html += `<div class="db-item">
            ${p.thumbnailDataUrl ? `<img src="${p.thumbnailDataUrl}">` : '<div style="width:100%;aspect-ratio:1;background:var(--bg-secondary);border-radius:6px;"></div>'}
            <div class="db-id">${pid.substring(0, 11)}</div>
        </div>`;
    });
    html += '</div>';
    
    if (Object.keys(clusters).length > 0) {
        html += `<hr style="border-color:var(--border);margin:20px 0;">`;
        html += `<p style="color:var(--text-secondary);margin-bottom:8px;"><strong>${Object.keys(clusters).length} ${T('groups')}</strong></p>`;
        Object.entries(clusters).forEach(([k, v]) => {
            html += `<p style="color:var(--text-muted);font-size:13px;">‚Ä¢ ${v.name || k} (${(v.piece_ids||[]).length} ${T('pieces')})</p>`;
        });
    }
    
    container.innerHTML = html;
}

// ==================================================
// RECONSTRUCTION RENDERING
// ==================================================
function renderReconOptions() {
    const container = document.getElementById('recon-content');
    if (activePieces.length === 0) {
        container.innerHTML = `<div class="empty-state"><div class="icon">üß©</div><p>${T('upload_first')}</p></div>`;
        // Also update 3D panel
        document.getElementById('recon-3d-empty').style.display = '';
        document.getElementById('recon-3d-main').style.display = 'none';
        return;
    }
    
    // 3D panel: show main, hide empty
    document.getElementById('recon-3d-empty').style.display = 'none';
    document.getElementById('recon-3d-main').style.display = '';
    updateRecon3DGroupSelect();
    
    const clusterIds = [...new Set(activePieces.map(p => p.cluster ?? -1))].filter(c => c >= 0).sort();
    
    let optionsHtml = '';
    clusterIds.forEach(cid => {
        const cp = activePieces.filter(p => p.cluster === cid);
        const name = clusterNames[cid] || `Group_${cid + 1}`;
        optionsHtml += `<option value="${cid}">${name} (${cp.length} ${T('pieces')})</option>`;
    });
    
    container.innerHTML = `
        <div class="recon-container">
            <div class="recon-main">
                <div class="form-group" style="margin-bottom:16px;">
                    <label>${T('select_group')}</label>
                    <select id="recon-group-select">${optionsHtml}</select>
                </div>
                <div class="slider-group" style="margin-bottom:16px;">
                    <div class="slider-label"><span>${T('canvas_size')}</span><span id="val-canvas-size">800</span></div>
                    <input type="range" id="slider-canvas-size" min="500" max="1200" value="800" step="50"
                           oninput="document.getElementById('val-canvas-size').textContent=this.value">
                </div>
                <button class="btn btn-primary btn-full" onclick="runReconstruction()">üß© ${T('reconstruct')}</button>
                <div class="recon-canvas-wrapper" style="margin-top:16px;" id="recon-canvas-wrapper">
                    <canvas id="recon-canvas" width="800" height="800"></canvas>
                </div>
                <button class="btn btn-secondary btn-full" style="margin-top:8px;" onclick="downloadReconImage()" id="btn-download-recon" style="display:none;">
                    üì• ${T('export_img')}
                </button>
            </div>
            <div class="recon-sidebar">
                <h4 style="margin-bottom:12px;">${T('edge_matches')}</h4>
                <div class="match-list" id="match-list"></div>
            </div>
        </div>
    `;
}

function downloadReconImage() {
    const canvas = document.getElementById('recon-canvas');
    if (!canvas) return;
    const link = document.createElement('a');
    link.download = 'reconstruction.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// ==================================================
// CHANGELOG RENDERING
// ==================================================
function renderChangelog() {
    const container = document.getElementById('changelog-content');
    let html = '';
    
    const sorted = Object.entries(CHANGELOG).sort((a, b) => b[0].localeCompare(a[0]));
    sorted.forEach(([version, data]) => {
        const isCurrent = version === APP_VERSION;
        html += `<div class="changelog-version ${isCurrent ? 'current' : ''}">
            <div style="display:flex;justify-content:space-between;align-items:center;">
                <span class="changelog-tag">v${version} ‚Äî ${data.title} ${isCurrent ? `(${T('changelog_current')})` : ''}</span>
                <span class="changelog-date">üìÖ ${data.date}</span>
            </div>`;
        if (data.features?.length) {
            html += `<p style="color:var(--text-secondary);font-size:13px;margin-top:8px;font-weight:600;">${T('changelog_features')}:</p><ul class="changelog-list">`;
            data.features.forEach(f => html += `<li>${f}</li>`);
            html += '</ul>';
        }
        if (data.fixes?.length) {
            html += `<p style="color:var(--text-secondary);font-size:13px;margin-top:8px;font-weight:600;">${T('changelog_fixes')}:</p><ul class="changelog-list">`;
            data.fixes.forEach(f => html += `<li>${f}</li>`);
            html += '</ul>';
        }
        html += '</div>';
    });
    
    container.innerHTML = html;
}

// ==================================================
// EXPORT & DELETE ACCOUNT
// ==================================================
function exportUserData() {
    const data = getUserData();
    const db = getDB();
    const user = db[currentUser];
    const exported = {
        username: currentUser,
        created: user?.created,
        pieces_count: Object.keys(data.pieces || {}).length,
        clusters_count: Object.keys(data.clusters || {}).length,
        pieces: Object.keys(data.pieces || {}),
        clusters: Object.keys(data.clusters || {}),
    };
    document.getElementById('export-data-output').innerHTML =
        `<pre style="background:var(--bg-secondary);padding:16px;border-radius:var(--radius);font-size:12px;overflow:auto;max-height:300px;color:var(--text-secondary);font-family:'JetBrains Mono',monospace;">${JSON.stringify(exported, null, 2)}</pre>`;
}

function showDeleteAccountModal() { document.getElementById('delete-modal').classList.add('show'); }
function hideDeleteAccountModal() { document.getElementById('delete-modal').classList.remove('show'); }

function confirmDeleteAccount() {
    const db = getDB();
    delete db[currentUser];
    saveDB(db);
    localStorage.removeItem('shardmind_cookie_consent');
    hideDeleteAccountModal();
    handleLogout();
    toast('Account deleted', 'info');
}

// ==================================================
// PDF LABELS (using jsPDF)
// ==================================================
function createLabelsPDF() {
    // Determine which pieces to label
    const activeSource = document.querySelector('.label-option.active')?.textContent;
    let pieces = [];
    
    if (activeSource?.includes(T('label_session')) || activeSource?.includes('session') || activeSource?.includes('Aktuelle')) {
        pieces = activePieces;
    } else if (activeSource?.includes(T('label_database')) || activeSource?.includes('Datenbank') || activeSource?.includes('Database')) {
        const data = getUserData();
        pieces = Object.values(data.pieces || {});
    } else {
        pieces = customLabels;
    }
    
    if (pieces.length === 0) {
        toast(T('upload_first'), 'error');
        return;
    }
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'a4');
    const pageW = 210, pageH = 297;
    const marginL = 12, marginT = 18, marginR = 12, marginB = 12;
    const cols = 3, rows = 4;
    const cellW = (pageW - marginL - marginR) / cols;
    const cellH = (pageH - marginT - marginB) / rows;
    const qrSize = 22;
    const padding = 4;
    const itemsPerPage = cols * rows;
    
    pieces.forEach((piece, idx) => {
        if (idx > 0 && idx % itemsPerPage === 0) doc.addPage();
        
        const pageIdx = idx % itemsPerPage;
        const col = pageIdx % cols;
        const row = Math.floor(pageIdx / cols);
        const cellX = marginL + col * cellW;
        const cellY = marginT + row * cellH;
        
        // Header on each new page
        if (pageIdx === 0) {
            doc.setFillColor(51, 76, 127);
            doc.rect(marginL, 4, pageW - marginL - marginR, 10, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(11);
            doc.text(`üè∫ ShardMind - ${currentUser}`, marginL + 3, 11);
            doc.setFontSize(9);
            const dateStr = new Date().toLocaleDateString('de-DE');
            doc.text(`${dateStr} | ${pieces.length} Labels`, pageW - marginR - 3, 11, { align: 'right' });
        }
        
        // Cell background
        doc.setFillColor((col + row) % 2 === 0 ? 250 : 255, (col + row) % 2 === 0 ? 250 : 255, (col + row) % 2 === 0 ? 250 : 255);
        doc.rect(cellX, cellY, cellW, cellH, 'F');
        
        // Cell border
        doc.setDrawColor(190, 190, 190);
        doc.setLineWidth(0.3);
        doc.rect(cellX, cellY, cellW, cellH, 'S');
        
        // QR Code
        const pieceId = piece.id || genId();
        const url = `${BASE_URL}/?piece=${pieceId}`;
        
        try {
            const qrDiv = document.createElement('div');
            qrDiv.style.position = 'absolute';
            qrDiv.style.left = '-9999px';
            document.body.appendChild(qrDiv);
            
            const qrCode = new QRCode(qrDiv, { text: url, width: 128, height: 128, correctLevel: QRCode.CorrectLevel.M });
            
            setTimeout(() => {
                const qrCanvas = qrDiv.querySelector('canvas');
                if (qrCanvas) {
                    const qrData = qrCanvas.toDataURL('image/png');
                    const qrX = cellX + (cellW - qrSize) / 2;
                    doc.addImage(qrData, 'PNG', qrX, cellY + padding, qrSize, qrSize);
                }
                document.body.removeChild(qrDiv);
            }, 50);
        } catch (e) {
            // QR code fallback - draw a simple placeholder
            doc.setDrawColor(200, 200, 200);
            const qrX = cellX + (cellW - qrSize) / 2;
            doc.rect(qrX, cellY + padding, qrSize, qrSize, 'S');
        }
        
        // Text
        let textY = cellY + padding + qrSize + 6;
        
        doc.setTextColor(30, 30, 30);
        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        doc.text(pieceId, cellX + cellW / 2, textY, { align: 'center' });
        
        textY += 4;
        doc.setFontSize(7);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(80, 80, 80);
        doc.text((piece.name || 'Fragment').substring(0, 28), cellX + cellW / 2, textY, { align: 'center' });
        
        if (piece.material) {
            textY += 3.5;
            doc.text(`Material: ${piece.material.substring(0, 20)}`, cellX + cellW / 2, textY, { align: 'center' });
        }
        
        if (piece.excavation) {
            textY += 3.5;
            doc.setFontSize(6);
            doc.setTextColor(130, 130, 130);
            doc.text(`üìç ${piece.excavation.substring(0, 25)}`, cellX + cellW / 2, textY, { align: 'center' });
        }
        
        textY += 3;
        doc.setFontSize(5);
        doc.text(new Date().toLocaleDateString('de-DE'), cellX + cellW / 2, textY, { align: 'center' });
    });
    
    // Footer
    doc.setFontSize(6);
    doc.setTextColor(130, 130, 130);
    doc.text(`ShardMind v${APP_VERSION} | ${BASE_URL}`, marginL, pageH - 6);
    
    // Small delay to allow QR codes to render, then save
    setTimeout(() => {
        doc.save(`labels_${new Date().toISOString().slice(0,10)}.pdf`);
        toast('PDF created!', 'success');
    }, 200);
}

// ==================================================
// ANALYSIS (calls Python via PyScript)
// ==================================================
async function runAnalysis() {
    if (uploadedFiles.length === 0) {
        toast(T('upload_first'), 'error');
        return;
    }
    
    if (!pyReady) {
        const elapsed = Math.round((Date.now() - pyLoadStartTime) / 1000);
        const statusBar = document.getElementById('py-status-bar');
        const isError = statusBar && statusBar.classList.contains('error');
        
        if (isError) {
            toast(currentLang === 'de' 
                ? 'Python-Umgebung konnte nicht geladen werden. Bitte Seite neu laden (Retry-Button in der Sidebar).'
                : 'Python environment failed to load. Please reload the page (Retry button in sidebar).', 
                'error');
        } else {
            toast(currentLang === 'de'
                ? `Python-Umgebung l√§dt noch (${elapsed}s). Bitte warten ‚Äî die Pakete werden heruntergeladen (~50 MB).`
                : `Python environment still loading (${elapsed}s). Please wait ‚Äî packages are downloading (~50 MB).`,
                'info');
        }
        return;
    }
    
    const progress = document.getElementById('analysis-progress');
    const progressBar = document.getElementById('progress-bar-inner');
    const progressText = document.getElementById('progress-text');
    progress.style.display = '';
    progressText.textContent = T('analyzing');
    progressBar.style.width = '10%';
    
    const minArea = parseInt(document.getElementById('slider-min-size').value);
    const threshold = parseInt(document.getElementById('slider-cluster-sens').value);
    const separation = parseFloat(document.getElementById('slider-separation').value) / 10;
    const mode = document.getElementById('select-mode').value;
    const project = document.getElementById('input-project').value;
    
    activePieces = [];
    
    for (let i = 0; i < uploadedFiles.length; i++) {
        progressText.textContent = `${T('analyzing')} ${i+1}/${uploadedFiles.length}`;
        progressBar.style.width = `${(i + 1) / uploadedFiles.length * 80}%`;
        
        try {
            const fileData = await readFileAsArrayBuffer(uploadedFiles[i]);
            const uint8 = new Uint8Array(fileData);
            
            // Call Python analysis
            const result = await callPyAnalysis(uint8, minArea, mode, separation, project);
            
            if (result && result.length > 0) {
                activePieces.push(...result);
            }
        } catch (err) {
            console.error('Analysis error for file', uploadedFiles[i].name, err);
        }
    }
    
    // Cluster
    if (activePieces.length > 1) {
        try {
            const labels = await callPyClustering(activePieces, threshold);
            labels.forEach((label, i) => {
                if (i < activePieces.length) activePieces[i].cluster = label;
            });
        } catch (err) {
            console.error('Clustering error', err);
            activePieces.forEach((p, i) => p.cluster = 0);
        }
    } else if (activePieces.length === 1) {
        activePieces[0].cluster = 0;
    }
    
    progressBar.style.width = '100%';
    progressText.textContent = `‚úì ${activePieces.length} ${T('success_fragments')}`;
    
    setTimeout(() => {
        progress.style.display = 'none';
        
        // Update metrics
        const clusterIds = [...new Set(activePieces.map(p => p.cluster ?? -1))].filter(c => c >= 0);
        document.getElementById('metric-fragments').textContent = activePieces.length;
        document.getElementById('metric-groups').textContent = clusterIds.length;
        document.getElementById('metric-project').textContent = project.substring(0, 15);
        document.getElementById('metrics-row').style.display = '';
        
        renderGallery();
        renderGroups();
        renderReconOptions();
        renderDatabase();
        renderDecoSelection();
        
        toast(`${activePieces.length} ${T('success_fragments')}`, 'success');
    }, 500);
}

function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
    });
}

function clearAnalysis() {
    activePieces = [];
    clusterLabels = [];
    clusterNames = {};
    reconImage = null;
    reconMatches = [];
    uploadedFiles = [];
    document.getElementById('file-input').value = '';
    document.getElementById('upload-files-list').innerHTML = '';
    document.getElementById('metrics-row').style.display = 'none';
    
    renderGallery();
    renderGroups();
    renderReconOptions();
    renderDecoSelection();
    document.getElementById('culture-results').innerHTML = '';
    document.getElementById('culture-empty').style.display = '';
    selectedDecoFragment = null;
    decoOriginalImg = null;
    decoLineArtImg = null;
    decoSvgData = null;
    
    toast('Cleared', 'info');
}

// ==================================================
// RECONSTRUCTION (calls Python)
// ==================================================
async function runReconstruction() {
    const select = document.getElementById('recon-group-select');
    if (!select) return;
    const cid = parseInt(select.value);
    const canvasSize = parseInt(document.getElementById('slider-canvas-size')?.value || 800);
    
    const rp = activePieces.filter(p => p.cluster === cid);
    if (rp.length === 0) { toast('No pieces in group', 'error'); return; }
    
    toast('Reconstructing...', 'info');
    
    try {
        const result = await callPyReconstruction(rp, canvasSize);
        if (result && result.imageDataUrl) {
            const canvas = document.getElementById('recon-canvas');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0);
            };
            img.src = result.imageDataUrl;
            
            const matchList = document.getElementById('match-list');
            if (result.matches && result.matches.length > 0) {
                matchList.innerHTML = result.matches.slice(0, 8).map(m =>
                    `<div class="match-item">
                        <span>Teil ${m.piece_i + 1} ‚Üî ${m.piece_j + 1}</span>
                        <span class="match-score">${m.score.toFixed(0)}%</span>
                    </div>`
                ).join('');
            } else {
                matchList.innerHTML = '<p style="color:var(--text-muted);font-size:13px;">Circle-fitting reconstruction (no edge matching needed)</p>';
            }
            
            toast(`Reconstruction complete`, 'success');
        }
    } catch (err) {
        console.error('Reconstruction error', err);
        toast('Reconstruction error: ' + err.message, 'error');
    }
}

// ==================================================
// 3D RECONSTRUCTION - THREE.JS
// ==================================================

let threeScene = null, threeCamera = null, threeRenderer = null;
let plateMesh = null, plateWireframe = null, fragmentBoundaries = null;
let threeAnimId = null;
let autoRotate = false;
let currentPlateType = 'flat';
let threeReady = false;
let assemblyAnimating = false;
let fragmentMeshes = [];
let plateTextureCanvas = null;
let reconImageData = null; // stores 2D reconstruction result

// Plate profiles: each is array of [radius_fraction, height_fraction] points
const PLATE_PROFILES = {
    flat: {
        name: 'Flachteller',
        points: [
            [0,     0],
            [0.15,  0],       // center flat
            [0.25,  -0.02],   // very slight dip
            [0.40,  -0.04],   // spiegel
            [0.55,  -0.02],   // transition
            [0.70,   0.10],   // fahne starts
            [0.82,   0.30],   // fahne mid
            [0.92,   0.55],   // approaching rim
            [0.97,   0.75],   // rim
            [1.00,   0.85],   // lip
            [1.02,   0.90],   // lip outer edge
        ],
        defaultDepth: 15,
        defaultRim: 25,
    },
    soup: {
        name: 'Suppenteller',
        points: [
            [0,     0],
            [0.10,  0],
            [0.18,  -0.05],
            [0.30,  -0.25],   // deep well
            [0.42,  -0.40],   // deepest
            [0.52,  -0.35],   // coming back up
            [0.62,  -0.15],   // transition
            [0.72,   0.10],   // fahne
            [0.82,   0.35],
            [0.92,   0.60],
            [0.97,   0.80],
            [1.00,   0.90],
            [1.02,   0.95],
        ],
        defaultDepth: 35,
        defaultRim: 30,
    },
    bowl: {
        name: 'Sch√ºssel',
        points: [
            [0,     0],
            [0.08,  0],
            [0.18,  -0.10],
            [0.30,  -0.35],
            [0.42,  -0.55],
            [0.55,  -0.70],
            [0.68,  -0.75],   // deep bowl
            [0.78,  -0.65],
            [0.85,  -0.40],
            [0.92,  -0.10],
            [0.97,   0.10],
            [1.00,   0.20],
            [1.01,   0.22],
        ],
        defaultDepth: 50,
        defaultRim: 55,
    },
    cup: {
        name: 'Tasse',
        points: [
            [0,     0],
            [0.08,  0],
            [0.15,  -0.05],
            [0.22,  -0.20],
            [0.28,  -0.45],
            [0.33,  -0.70],
            [0.37,  -0.90],
            [0.40,  -1.00],   // bottom of cup
            [0.42,  -0.95],
            [0.48,  -0.70],
            [0.56,  -0.40],
            [0.65,  -0.15],
            [0.75,   0.15],
            [0.85,   0.40],
            [0.92,   0.60],
            [0.97,   0.80],
            [1.00,   0.90],
            [1.01,   0.92],
        ],
        defaultDepth: 55,
        defaultRim: 45,
    }
};

function setReconMode(mode, btn) {
    document.querySelectorAll('.recon-mode-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    
    document.getElementById('recon-2d-panel').style.display = mode === '2d' ? '' : 'none';
    document.getElementById('recon-3d-panel').style.display = mode === '3d' ? '' : 'none';
    
    if (mode === '3d') {
        updateRecon3DGroupSelect();
        if (activePieces.length > 0) {
            document.getElementById('recon-3d-empty').style.display = 'none';
            document.getElementById('recon-3d-main').style.display = '';
        } else {
            document.getElementById('recon-3d-empty').style.display = '';
            document.getElementById('recon-3d-main').style.display = 'none';
        }
    }
}

function updateRecon3DGroupSelect() {
    const select = document.getElementById('recon-3d-group-select');
    if (!select) return;
    const clusterIds = [...new Set(activePieces.map(p => p.cluster ?? -1))].filter(c => c >= 0).sort();
    let html = '';
    clusterIds.forEach(cid => {
        const cp = activePieces.filter(p => p.cluster === cid);
        const name = clusterNames[cid] || `Group_${cid + 1}`;
        html += `<option value="${cid}">${name} (${cp.length} Teile)</option>`;
    });
    // Also add "all" option
    html += `<option value="-99">Alle Fragmente (${activePieces.length})</option>`;
    select.innerHTML = html;
}

function selectPlateType(type, btn) {
    currentPlateType = type;
    document.querySelectorAll('.plate-type-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    
    // Set defaults
    const profile = PLATE_PROFILES[type];
    document.getElementById('slider-plate-depth').value = profile.defaultDepth;
    document.getElementById('val-plate-depth').textContent = profile.defaultDepth;
    document.getElementById('slider-rim-angle').value = profile.defaultRim;
    document.getElementById('val-rim-angle').textContent = profile.defaultRim;
    
    if (threeReady) update3DPlate();
}

// ---------- THREE.JS SCENE SETUP ----------

function initThreeScene() {
    const container = document.getElementById('three-container');
    if (!container || threeScene) return;

    const w = container.clientWidth || 600;
    const h = w; // square

    // Scene
    threeScene = new THREE.Scene();
    threeScene.background = new THREE.Color(0x0a0b10);

    // Camera
    threeCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
    threeCamera.position.set(0, 3.5, 5);
    threeCamera.lookAt(0, 0, 0);

    // Renderer
    threeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, preserveDrawingBuffer: true });
    threeRenderer.setSize(w, h);
    threeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    threeRenderer.shadowMap.enabled = true;
    threeRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
    threeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
    threeRenderer.toneMappingExposure = 1.1;
    container.appendChild(threeRenderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xfff5e6, 0.5);
    threeScene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(5, 8, 5);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    threeScene.add(dirLight);

    const fillLight = new THREE.DirectionalLight(0xadc6ff, 0.3);
    fillLight.position.set(-3, 4, -3);
    threeScene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0xffe0c0, 0.2);
    rimLight.position.set(0, -2, 5);
    threeScene.add(rimLight);

    // Ground plane (subtle shadow catcher)
    const groundGeo = new THREE.PlaneGeometry(20, 20);
    const groundMat = new THREE.MeshStandardMaterial({ 
        color: 0x0d0e14, roughness: 1, metalness: 0 
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1.5;
    ground.receiveShadow = true;
    threeScene.add(ground);

    // Simple orbit controls (manual implementation for r128)
    setupOrbitControls(container);

    // Handle resize
    const resizeObs = new ResizeObserver(() => {
        const cw = container.clientWidth;
        const ch = cw;
        threeCamera.aspect = 1;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(cw, ch);
    });
    resizeObs.observe(container);

    threeReady = true;
    animate3D();
}

// ---------- ORBIT CONTROLS (manual for r128) ----------

let orbitState = { isDown: false, isRight: false, prevX: 0, prevY: 0, theta: 0.3, phi: 1.1, distance: 6, targetX: 0, targetY: 0 };

function setupOrbitControls(container) {
    container.addEventListener('mousedown', (e) => {
        orbitState.isDown = true;
        orbitState.isRight = (e.button === 2);
        orbitState.prevX = e.clientX;
        orbitState.prevY = e.clientY;
        e.preventDefault();
    });
    
    container.addEventListener('contextmenu', (e) => e.preventDefault());

    window.addEventListener('mouseup', () => { orbitState.isDown = false; });

    window.addEventListener('mousemove', (e) => {
        if (!orbitState.isDown) return;
        const dx = e.clientX - orbitState.prevX;
        const dy = e.clientY - orbitState.prevY;
        orbitState.prevX = e.clientX;
        orbitState.prevY = e.clientY;

        if (orbitState.isRight) {
            // Pan
            orbitState.targetX -= dx * 0.005;
            orbitState.targetY += dy * 0.005;
        } else {
            // Rotate
            orbitState.theta -= dx * 0.008;
            orbitState.phi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitState.phi - dy * 0.008));
        }
        updateOrbitCamera();
    });

    container.addEventListener('wheel', (e) => {
        e.preventDefault();
        orbitState.distance = Math.max(2, Math.min(15, orbitState.distance + e.deltaY * 0.005));
        updateOrbitCamera();
    }, { passive: false });

    // Touch support
    let lastTouchDist = 0;
    container.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            orbitState.isDown = true;
            orbitState.isRight = false;
            orbitState.prevX = e.touches[0].clientX;
            orbitState.prevY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            lastTouchDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
        }
        e.preventDefault();
    }, { passive: false });

    container.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && orbitState.isDown) {
            const dx = e.touches[0].clientX - orbitState.prevX;
            const dy = e.touches[0].clientY - orbitState.prevY;
            orbitState.prevX = e.touches[0].clientX;
            orbitState.prevY = e.touches[0].clientY;
            orbitState.theta -= dx * 0.008;
            orbitState.phi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitState.phi - dy * 0.008));
            updateOrbitCamera();
        } else if (e.touches.length === 2) {
            const dist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            orbitState.distance = Math.max(2, Math.min(15, orbitState.distance - (dist - lastTouchDist) * 0.02));
            lastTouchDist = dist;
            updateOrbitCamera();
        }
        e.preventDefault();
    }, { passive: false });

    container.addEventListener('touchend', () => { orbitState.isDown = false; });

    updateOrbitCamera();
}

function updateOrbitCamera() {
    if (!threeCamera) return;
    const r = orbitState.distance;
    threeCamera.position.set(
        r * Math.sin(orbitState.phi) * Math.sin(orbitState.theta) + orbitState.targetX,
        r * Math.cos(orbitState.phi) + orbitState.targetY,
        r * Math.sin(orbitState.phi) * Math.cos(orbitState.theta)
    );
    threeCamera.lookAt(orbitState.targetX, orbitState.targetY, 0);
}

function reset3DCamera() {
    orbitState = { isDown: false, isRight: false, prevX: 0, prevY: 0, theta: 0.3, phi: 1.1, distance: 6, targetX: 0, targetY: 0 };
    updateOrbitCamera();
}

// ---------- PLATE GEOMETRY GENERATION ----------

function generatePlateGeometry(plateType, depthMM, rimAngleDeg, baseFrac, wallThickness) {
    const profile = PLATE_PROFILES[plateType];
    if (!profile) return null;

    const depthScale = depthMM / 30; // normalize to a "standard" depth
    const rimScale = rimAngleDeg / 30;
    const radius = 2.0; // world units

    // Generate smooth profile from control points using interpolation
    const controlPts = profile.points;
    const numProfilePts = 40;
    const profilePoints = [];

    for (let i = 0; i < numProfilePts; i++) {
        const t = i / (numProfilePts - 1);
        const r = t * radius;
        
        // Find the two control points we're between
        const rFrac = t;
        let h = 0;
        
        for (let j = 0; j < controlPts.length - 1; j++) {
            const [r0, h0] = controlPts[j];
            const [r1, h1] = controlPts[j + 1];
            if (rFrac >= r0 && rFrac <= r1) {
                const localT = (rFrac - r0) / (r1 - r0 + 0.001);
                // Smooth interpolation (smoothstep)
                const smooth = localT * localT * (3 - 2 * localT);
                h = h0 + (h1 - h0) * smooth;
                break;
            }
        }
        if (rFrac > controlPts[controlPts.length - 1][0]) {
            h = controlPts[controlPts.length - 1][1];
        }

        const y = h * depthScale * rimScale * 0.15;
        profilePoints.push(new THREE.Vector2(r, y));
    }

    // Create LatheGeometry (inner surface)
    const segments = 64;
    const innerGeo = new THREE.LatheGeometry(profilePoints, segments, 0, Math.PI * 2);

    // Create outer surface (offset by wall thickness)
    const wt = wallThickness * 0.01; // scale to world units
    const outerProfilePts = profilePoints.map((pt, idx) => {
        // Normal direction: perpendicular to the profile tangent
        let nx = 0, ny = -1;
        if (idx > 0 && idx < profilePoints.length - 1) {
            const dx = profilePoints[idx + 1].x - profilePoints[idx - 1].x;
            const dy = profilePoints[idx + 1].y - profilePoints[idx - 1].y;
            const len = Math.sqrt(dx * dx + dy * dy) + 0.001;
            nx = -dy / len;
            ny = dx / len;
        }
        return new THREE.Vector2(pt.x + nx * wt, pt.y + ny * wt);
    });

    const outerGeo = new THREE.LatheGeometry(outerProfilePts, segments, 0, Math.PI * 2);

    return { innerGeo, outerGeo, profilePoints, outerProfilePts, segments };
}

// ---------- TEXTURE CREATION ----------

function createPlateTexture(pieces, plateRadius, plateCX, plateCY) {
    const texSize = 2048;
    const canvas = document.createElement('canvas');
    canvas.width = texSize;
    canvas.height = texSize;
    const ctx = canvas.getContext('2d');

    // Background: ceramic/clay color
    ctx.fillStyle = '#d4c4a8';
    ctx.beginPath();
    ctx.arc(texSize / 2, texSize / 2, texSize / 2, 0, Math.PI * 2);
    ctx.fill();

    // Add subtle ceramic texture
    for (let i = 0; i < 5000; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * texSize / 2;
        const x = texSize / 2 + r * Math.cos(angle);
        const y = texSize / 2 + r * Math.sin(angle);
        const shade = 180 + Math.random() * 40;
        ctx.fillStyle = `rgba(${shade}, ${shade - 15}, ${shade - 30}, 0.05)`;
        ctx.fillRect(x, y, 2 + Math.random() * 3, 2 + Math.random() * 3);
    }

    // Mark missing area with subtle pattern
    ctx.strokeStyle = 'rgba(100,90,75,0.08)';
    ctx.lineWidth = 1;
    for (let r = 0; r < texSize / 2; r += 20) {
        ctx.beginPath();
        ctx.arc(texSize / 2, texSize / 2, r, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Scale factor: how to map original pixel coords to texture coords
    const scale = (texSize / 2) / (plateRadius || 200);

    // Draw each fragment onto the texture
    let placedCount = 0;
    const fragBounds = []; // for boundary visualization

    pieces.forEach((piece, idx) => {
        if (!piece.thumbnailDataUrl) return;

        const img = new Image();
        img.src = piece.thumbnailDataUrl;

        // We need synchronous drawing, so we use a temp canvas
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');

        // Fragment position relative to plate center
        const offset = piece.offset || [0, 0];
        const cx = piece.centroid || [offset[0] + 30, offset[1] + 30];

        // Position on texture
        const relX = (cx[0] - (plateCX || 0)) * scale;
        const relY = (cx[1] - (plateCY || 0)) * scale;
        const texX = texSize / 2 + relX;
        const texY = texSize / 2 + relY;

        // Store for later async painting
        fragBounds.push({
            idx, texX, texY, scale,
            offset, dataUrl: piece.thumbnailDataUrl,
            bbox: piece.bbox || [0, 0, 60, 60]
        });

        placedCount++;
    });

    // Since Image loading is async, we return a promise
    plateTextureCanvas = canvas;

    return new Promise((resolve) => {
        let loaded = 0;

        if (fragBounds.length === 0) {
            resolve({ canvas, coverage: 0, placedCount: 0 });
            return;
        }

        fragBounds.forEach((fb) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                const w = img.width * fb.scale;
                const h = img.height * fb.scale;
                const dx = fb.texX - (fb.bbox[0] - fb.offset[0]) * fb.scale - w / 2;
                const dy = fb.texY - (fb.bbox[1] - fb.offset[1]) * fb.scale - h / 2;

                // Draw with transparency for non-ceramic pixels
                const tmpC = document.createElement('canvas');
                tmpC.width = img.width;
                tmpC.height = img.height;
                const tmpX = tmpC.getContext('2d');
                tmpX.drawImage(img, 0, 0);

                // Get pixel data and mask out white background
                const idata = tmpX.getImageData(0, 0, img.width, img.height);
                const d = idata.data;
                for (let px = 0; px < d.length; px += 4) {
                    if (d[px] > 235 && d[px + 1] > 235 && d[px + 2] > 235) {
                        d[px + 3] = 0; // transparent
                    }
                }
                tmpX.putImageData(idata, 0, 0);

                // Draw onto texture at correct position
                const posX = fb.texX - w * 0.5;
                const posY = fb.texY - h * 0.5;
                ctx.drawImage(tmpC, posX, posY, w, h);

                loaded++;
                if (loaded >= fragBounds.length) {
                    // Calculate coverage
                    const totalPx = texSize * texSize;
                    const texData = ctx.getImageData(0, 0, texSize, texSize).data;
                    let ceramicPx = 0;
                    const centerX = texSize / 2, centerY = texSize / 2;
                    const maxR = texSize / 2;
                    for (let y = 0; y < texSize; y += 4) {
                        for (let x = 0; x < texSize; x += 4) {
                            const dr = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                            if (dr > maxR) continue;
                            const pi = (y * texSize + x) * 4;
                            const r = texData[pi], g = texData[pi + 1], b = texData[pi + 2];
                            // Check if this pixel is from a fragment (not the background clay color)
                            if (Math.abs(r - 212) > 15 || Math.abs(g - 196) > 15 || Math.abs(b - 168) > 15) {
                                ceramicPx++;
                            }
                        }
                    }
                    const platePxTotal = Math.PI * (maxR / 4) ** 2; // approx circle area at sampled resolution
                    const coverage = Math.min(100, (ceramicPx / platePxTotal * 100).toFixed(0));

                    resolve({ canvas, coverage, placedCount });
                }
            };
            img.onerror = () => {
                loaded++;
                if (loaded >= fragBounds.length) {
                    resolve({ canvas, coverage: 0, placedCount });
                }
            };
            img.src = fb.dataUrl;
        });
    });
}

// ---------- BUILD 3D PLATE ----------

async function run3DReconstruction() {
    if (activePieces.length === 0) {
        toast('Bitte zuerst Fotos analysieren', 'error');
        return;
    }

    const select = document.getElementById('recon-3d-group-select');
    const cid = parseInt(select?.value ?? -99);
    let pieces = cid === -99 ? activePieces : activePieces.filter(p => p.cluster === cid);
    if (pieces.length === 0) pieces = activePieces;

    toast('Berechne 3D-Rekonstruktion...', 'info');

    // Show container
    document.getElementById('three-container').style.display = '';
    document.getElementById('three-toggles').style.display = 'flex';
    document.getElementById('stats-3d').style.display = 'grid';
    document.getElementById('three-export-btns').style.display = 'flex';

    // Init Three.js if needed
    if (!threeReady) initThreeScene();

    // Get plate parameters
    const depth = parseInt(document.getElementById('slider-plate-depth').value);
    const rimAngle = parseInt(document.getElementById('slider-rim-angle').value);
    const baseFrac = parseInt(document.getElementById('slider-base-frac').value);
    const wallThick = parseFloat(document.getElementById('slider-wall-thick').value);

    // First: do circle fitting to get plate center and radius
    let plateCX = 0, plateCY = 0, plateRadius = 200;
    // Use Python circle fitting if available, else estimate from centroids
    const centroids = pieces.filter(p => p.centroid).map(p => p.centroid);
    if (centroids.length > 0) {
        plateCX = centroids.reduce((s, c) => s + c[0], 0) / centroids.length;
        plateCY = centroids.reduce((s, c) => s + c[1], 0) / centroids.length;
        const dists = centroids.map(c => Math.sqrt((c[0] - plateCX) ** 2 + (c[1] - plateCY) ** 2));
        plateRadius = Math.max(80, Math.max(...dists) * 1.3);
    }

    // Create texture from fragments
    const texResult = await createPlateTexture(pieces, plateRadius, plateCX, plateCY);

    // Clear old meshes
    if (plateMesh) {
        plateMesh.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (child.material.map) child.material.map.dispose();
                child.material.dispose();
            }
        });
        threeScene.remove(plateMesh);
    }
    if (plateWireframe) { threeScene.remove(plateWireframe); plateWireframe.geometry.dispose(); plateWireframe.material.dispose(); }
    if (fragmentBoundaries) { threeScene.remove(fragmentBoundaries); }
    fragmentMeshes.forEach(m => { threeScene.remove(m); m.geometry?.dispose(); m.material?.dispose(); });
    fragmentMeshes = [];

    // Generate plate geometry
    const geoData = generatePlateGeometry(currentPlateType, depth, rimAngle, baseFrac, wallThick);
    if (!geoData) { toast('Geometry error', 'error'); return; }

    // Create texture from canvas
    const texture = new THREE.CanvasTexture(texResult.canvas);
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.minFilter = THREE.LinearMipmapLinearFilter;
    texture.magFilter = THREE.LinearFilter;

    // Inner surface material (glazed with fragment texture)
    const innerMat = new THREE.MeshStandardMaterial({
        map: texture,
        roughness: 0.3,
        metalness: 0.02,
        side: THREE.FrontSide,
    });

    // Fix UV mapping for LatheGeometry to be radial (center-to-rim)
    fixPlateUVs(geoData.innerGeo, geoData.profilePoints);

    const innerMesh = new THREE.Mesh(geoData.innerGeo, innerMat);
    innerMesh.castShadow = true;
    innerMesh.receiveShadow = true;

    // Outer surface material (unglazed ceramic)
    const outerMat = new THREE.MeshStandardMaterial({
        color: 0xc4a882,
        roughness: 0.85,
        metalness: 0.0,
        side: THREE.FrontSide,
    });

    // Flip outer normals
    const outerGeo = geoData.outerGeo;
    const posAttr = outerGeo.getAttribute('position');
    const normAttr = outerGeo.getAttribute('normal');
    const idxAttr = outerGeo.getIndex();
    // Reverse winding order
    if (idxAttr) {
        const indices = idxAttr.array;
        for (let i = 0; i < indices.length; i += 3) {
            const tmp = indices[i];
            indices[i] = indices[i + 2];
            indices[i + 2] = tmp;
        }
        idxAttr.needsUpdate = true;
    }
    // Flip normals
    for (let i = 0; i < normAttr.count; i++) {
        normAttr.setXYZ(i, -normAttr.getX(i), -normAttr.getY(i), -normAttr.getZ(i));
    }
    normAttr.needsUpdate = true;

    const outerMesh = new THREE.Mesh(outerGeo, outerMat);
    outerMesh.castShadow = true;

    // Group inner + outer
    const plateGroup = new THREE.Group();
    plateGroup.add(innerMesh);
    plateGroup.add(outerMesh);

    // Add rim/lip connecting ring
    const rimGeo = createRimGeometry(geoData.profilePoints, geoData.outerProfilePts, geoData.segments);
    if (rimGeo) {
        const rimMesh = new THREE.Mesh(rimGeo, outerMat.clone());
        plateGroup.add(rimMesh);
    }

    plateMesh = plateGroup;
    threeScene.add(plateMesh);

    // Wireframe overlay
    const wireGeo = geoData.innerGeo.clone();
    const wireMat = new THREE.MeshBasicMaterial({ color: 0xc9956b, wireframe: true, transparent: true, opacity: 0.15 });
    plateWireframe = new THREE.Mesh(wireGeo, wireMat);
    fixPlateUVs(wireGeo, geoData.profilePoints);
    plateWireframe.visible = false;
    threeScene.add(plateWireframe);

    // Update stats
    document.getElementById('stat-coverage').textContent = texResult.coverage + '%';
    document.getElementById('stat-fragments-placed').textContent = texResult.placedCount;
    document.getElementById('stat-diameter').textContent = (plateRadius * 0.5).toFixed(0) + ' mm';

    // Run assembly animation
    runAssemblyAnimation(pieces, geoData, plateCX, plateCY, plateRadius);

    toast('3D-Rekonstruktion abgeschlossen!', 'success');
}

function fixPlateUVs(geometry, profilePoints) {
    // For a plate, we want UV mapping where:
    // u,v map to a top-down circular projection (like looking straight down at the plate)
    const posAttr = geometry.getAttribute('position');
    const uvAttr = geometry.getAttribute('uv');

    if (!uvAttr) return;

    const maxR = profilePoints[profilePoints.length - 1]?.x || 2;

    for (let i = 0; i < posAttr.count; i++) {
        const x = posAttr.getX(i);
        const z = posAttr.getZ(i);
        // Map to polar coordinates, then to UV
        const r = Math.sqrt(x * x + z * z);
        const angle = Math.atan2(z, x);
        // Convert to circular UV mapping
        const uv_r = r / (maxR * 1.05); // normalize
        const u = 0.5 + uv_r * Math.cos(angle) * 0.5;
        const v = 0.5 + uv_r * Math.sin(angle) * 0.5;
        uvAttr.setXY(i, u, v);
    }
    uvAttr.needsUpdate = true;
}

function createRimGeometry(innerProfile, outerProfile, segments) {
    // Connect the last points of inner and outer profiles around the circumference
    if (!innerProfile || !outerProfile || innerProfile.length < 2 || outerProfile.length < 2) return null;

    const innerLast = innerProfile[innerProfile.length - 1];
    const outerLast = outerProfile[outerProfile.length - 1];

    const points = [];
    const indices = [];

    for (let s = 0; s <= segments; s++) {
        const angle = (s / segments) * Math.PI * 2;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);

        // Inner rim point
        points.push(innerLast.x * cos, innerLast.y, innerLast.x * sin);
        // Outer rim point
        points.push(outerLast.x * cos, outerLast.y, outerLast.x * sin);
    }

    for (let s = 0; s < segments; s++) {
        const i0 = s * 2;
        const i1 = s * 2 + 1;
        const i2 = (s + 1) * 2;
        const i3 = (s + 1) * 2 + 1;
        indices.push(i0, i1, i2);
        indices.push(i1, i3, i2);
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
    geo.setIndex(indices);
    geo.computeVertexNormals();
    return geo;
}

// ---------- ASSEMBLY ANIMATION ----------

function runAssemblyAnimation(pieces, geoData, plateCX, plateCY, plateRadius) {
    assemblyAnimating = true;
    const progress = document.getElementById('assembly-progress');
    const progressBar = document.getElementById('assembly-bar-fill');
    const progressText = document.getElementById('assembly-progress-text');
    progress.style.display = '';

    // Make plate transparent initially
    plateMesh.children.forEach(child => {
        if (child.material) {
            child.material.transparent = true;
            child.material.opacity = 0;
        }
    });

    // Animate: fade in plate, then show fragments settling
    const totalDuration = 2500; // ms
    const startTime = performance.now();

    function animateAssembly() {
        const elapsed = performance.now() - startTime;
        const t = Math.min(1, elapsed / totalDuration);

        // Phase 1: Plate fades in (0-40%)
        const plateT = Math.min(1, t / 0.4);
        const plateOpacity = smoothstep(plateT);
        plateMesh.children.forEach(child => {
            if (child.material) {
                child.material.opacity = plateOpacity;
                if (plateOpacity >= 0.99) child.material.transparent = false;
            }
        });

        // Phase 2: Plate rises (0-60%)
        const riseT = Math.min(1, t / 0.6);
        plateMesh.position.y = -0.5 + smoothstep(riseT) * 0.5;

        // Phase 3: Gentle rotation
        if (t < 1) {
            plateMesh.rotation.y = t * Math.PI * 0.5;
        }

        // Update progress
        const pct = Math.min(100, Math.round(t * 100));
        progressBar.style.width = pct + '%';
        progressText.textContent = `Montage: ${pct}%`;

        if (t < 1) {
            requestAnimationFrame(animateAssembly);
        } else {
            // Done
            assemblyAnimating = false;
            progress.style.display = 'none';
            plateMesh.children.forEach(child => {
                if (child.material) {
                    child.material.transparent = false;
                    child.material.opacity = 1;
                }
            });
        }
    }

    requestAnimationFrame(animateAssembly);
}

function smoothstep(t) {
    return t * t * (3 - 2 * t);
}

// ---------- UPDATE PLATE (live when sliders change) ----------

let updateTimeout = null;
function update3DPlate() {
    if (!threeReady || !plateMesh) return;
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() => {
        run3DReconstruction();
    }, 300);
}

// ---------- TOGGLE OPTIONS ----------

let showTexture = true, showWireframe = false, showFragBounds = false, showUnderside = false;

function toggle3DOption(el, option) {
    el.classList.toggle('active');
    const isActive = el.classList.contains('active');

    switch (option) {
        case 'texture':
            showTexture = isActive;
            if (plateMesh && plateMesh.children[0]) {
                plateMesh.children[0].material.map = showTexture ? plateMesh.children[0].material.map : null;
                plateMesh.children[0].material.color = showTexture ? new THREE.Color(0xffffff) : new THREE.Color(0xd4c4a8);
                plateMesh.children[0].material.needsUpdate = true;
            }
            break;
        case 'wireframe':
            showWireframe = isActive;
            if (plateWireframe) plateWireframe.visible = showWireframe;
            break;
        case 'fragments':
            showFragBounds = isActive;
            // Toggle fragment boundary visibility
            break;
        case 'animate':
            if (isActive && plateMesh && activePieces.length > 0) {
                run3DReconstruction(); // re-run to replay animation
            }
            el.classList.remove('active');
            break;
        case 'rotate':
            autoRotate = isActive;
            break;
        case 'underside':
            showUnderside = isActive;
            if (isActive) {
                orbitState.phi = Math.PI - 0.5;
                orbitState.theta = 0;
            } else {
                orbitState.phi = 1.1;
            }
            updateOrbitCamera();
            break;
    }
}

// ---------- EXPORT ----------

function export3DScreenshot() {
    if (!threeRenderer) return;
    threeRenderer.render(threeScene, threeCamera);
    const link = document.createElement('a');
    link.download = `shardmind_3d_${Date.now()}.png`;
    link.href = threeRenderer.domElement.toDataURL('image/png');
    link.click();
    toast('Screenshot gespeichert!', 'success');
}

// ---------- ANIMATION LOOP ----------

function animate3D() {
    threeAnimId = requestAnimationFrame(animate3D);
    if (!threeScene || !threeCamera || !threeRenderer) return;

    if (autoRotate && plateMesh && !assemblyAnimating) {
        plateMesh.rotation.y += 0.005;
    }

    threeRenderer.render(threeScene, threeCamera);
}

// ==================================================
// CULTURE PERIOD KNOWLEDGE BASE
// ==================================================
const CULTURE_DB = {
    neolithic: {
        name_de: 'Neolithikum', name_en: 'Neolithic',
        period: 'ca. 5500‚Äì2200 v.Chr.',
        icon: 'ü™®',
        class: 'neolithic',
        criteria: {
            wall_thickness: { de: 'Dick (8‚Äì15 mm), unregelm√§√üig', en: 'Thick (8‚Äì15 mm), irregular' },
            surface: { de: 'Rau, oft gegl√§ttet oder poliert', en: 'Rough, often smoothed or polished' },
            firing: { de: 'Niedrig (600‚Äì800¬∞C), oxidierend/reduzierend gemischt', en: 'Low (600‚Äì800¬∞C), mixed oxidizing/reducing' },
            temper: { de: 'Grob: Quarz, Feldspat, Schamotte, Pflanzenmaterial', en: 'Coarse: quartz, feldspar, grog, plant material' },
            decoration: { de: 'Ritzlinien, Einstiche, Bandkeramik, Schnureindr√ºcke', en: 'Incised lines, punctures, Linear Pottery, cord impressions' },
            typical_forms: { de: 'Kugelt√∂pfe, Sch√ºsseln, Vorratsgef√§√üe', en: 'Globular pots, bowls, storage vessels' },
        },
        color_hints: ['Braun', 'Schwarz', 'Grau', 'Orange'],
        material_hints: ['Keramik'],
        decoration_hints: ['incised', 'stamped'],
    },
    'bronze-age': {
        name_de: 'Bronzezeit', name_en: 'Bronze Age',
        period: 'ca. 2200‚Äì800 v.Chr.',
        icon: '‚öîÔ∏è',
        class: 'bronze-age',
        criteria: {
            wall_thickness: { de: 'Mittel (5‚Äì10 mm), regelm√§√üiger', en: 'Medium (5‚Äì10 mm), more regular' },
            surface: { de: 'Gegl√§ttet, teils poliert oder geschlickt', en: 'Smoothed, partly polished or slipped' },
            firing: { de: 'Verbessert (700‚Äì900¬∞C)', en: 'Improved (700‚Äì900¬∞C)' },
            temper: { de: 'Feiner: Quarz, Glimmer, Kalkstein', en: 'Finer: quartz, mica, limestone' },
            decoration: { de: 'Rillen, Buckel, Kerbleisten, Fingertupfen', en: 'Grooves, bosses, notched strips, finger impressions' },
            typical_forms: { de: 'Urnen, Tassen, Amphoren, Siebgef√§√üe', en: 'Urns, cups, amphorae, strainer vessels' },
        },
        color_hints: ['Braun', 'Orange', 'Rot'],
        material_hints: ['Keramik'],
        decoration_hints: ['ornamental', 'band', 'stamped'],
    },
    'iron-age': {
        name_de: 'Eisenzeit', name_en: 'Iron Age',
        period: 'ca. 800 v.Chr. ‚Äì Zeitenwende',
        icon: 'üó°Ô∏è',
        class: 'iron-age',
        criteria: {
            wall_thickness: { de: 'Variabel (3‚Äì10 mm), fein bei Drehscheibenware', en: 'Variable (3‚Äì10 mm), fine on wheel-thrown ware' },
            surface: { de: 'Graphitiert, poliert, Kammstrich', en: 'Graphite-coated, polished, combed' },
            firing: { de: 'Fortgeschritten (800‚Äì1000¬∞C)', en: 'Advanced (800‚Äì1000¬∞C)' },
            temper: { de: 'Fein bis mittel, oft Graphit-Beimengung', en: 'Fine to medium, often graphite admixture' },
            decoration: { de: 'Graphitbemalung, Stempelmuster, Kammstrich, plastische Leisten', en: 'Graphite painting, stamp patterns, comb decoration, applied strips' },
            typical_forms: { de: 'Situlae, Schalen, Graphittonware, Drehscheibenkeramik', en: 'Situlae, bowls, graphite ware, wheel-thrown ceramics' },
        },
        color_hints: ['Schwarz', 'Grau', 'Braun'],
        material_hints: ['Keramik'],
        decoration_hints: ['stamped', 'painted', 'ornamental'],
    },
    roman: {
        name_de: 'R√∂misch', name_en: 'Roman',
        period: 'ca. 1. Jh. v.Chr. ‚Äì 5. Jh. n.Chr.',
        icon: 'üèõÔ∏è',
        class: 'roman',
        criteria: {
            wall_thickness: { de: 'D√ºnn (2‚Äì6 mm), gleichm√§√üig, Drehscheibe', en: 'Thin (2‚Äì6 mm), uniform, wheel-thrown' },
            surface: { de: 'Terra Sigillata: Glanzton√ºberzug; Gebrauchskeramik: glatt', en: 'Terra sigillata: gloss slip; common ware: smooth' },
            firing: { de: 'Hoch (900‚Äì1100¬∞C), kontrolliert oxidierend', en: 'High (900‚Äì1100¬∞C), controlled oxidizing' },
            temper: { de: 'Sehr fein, kaum sichtbar', en: 'Very fine, barely visible' },
            decoration: { de: 'Reliefdekor (Formsch√ºssel), Barbotine, R√§dchenverzierung, Stempel', en: 'Relief decor (mold), barbotine, rouletting, stamps' },
            typical_forms: { de: 'Terra Sigillata, Amphoren, Mortaria, Dolien', en: 'Terra sigillata, amphorae, mortaria, dolia' },
        },
        color_hints: ['Rot', 'Orange'],
        material_hints: ['Keramik', 'Porzellan'],
        decoration_hints: ['figural', 'stamped', 'ornamental'],
    },
    medieval: {
        name_de: 'Mittelalter', name_en: 'Medieval',
        period: 'ca. 5.‚Äì15. Jh. n.Chr.',
        icon: 'üè∞',
        class: 'medieval',
        criteria: {
            wall_thickness: { de: 'Mittel (4‚Äì8 mm), Drehscheibe und Handaufbau', en: 'Medium (4‚Äì8 mm), wheel and hand-built' },
            surface: { de: 'Steinzeug: gesintert; Irdenware: engobiert/glasiert', en: 'Stoneware: sintered; earthenware: slipped/glazed' },
            firing: { de: 'Steinzeug bis 1300¬∞C; Irdenware 900‚Äì1100¬∞C', en: 'Stoneware up to 1300¬∞C; earthenware 900‚Äì1100¬∞C' },
            temper: { de: 'Fein bis mittel, Quarz, Feldspat', en: 'Fine to medium, quartz, feldspar' },
            decoration: { de: 'Wellenb√§nder, Rollstempel, Glasur, Ritzdekor, aufgelegte Leisten', en: 'Wavy bands, roller stamps, glaze, incised, applied strips' },
            typical_forms: { de: 'Kugelt√∂pfe, Kannen, Kr√ºge, Grapen', en: 'Globular pots, pitchers, jugs, tripod pots' },
        },
        color_hints: ['Grau', 'Braun', 'Gr√ºn'],
        material_hints: ['Keramik'],
        decoration_hints: ['band', 'stamped', 'ornamental', 'incised'],
    },
    'early-modern': {
        name_de: 'Fr√ºhe Neuzeit', name_en: 'Early Modern',
        period: 'ca. 15.‚Äì18. Jh.',
        icon: '‚öôÔ∏è',
        class: 'modern',
        criteria: {
            wall_thickness: { de: 'D√ºnn (2‚Äì5 mm), Fayence/Steinzeug', en: 'Thin (2‚Äì5 mm), faience/stoneware' },
            surface: { de: 'Zinnglasur (Fayence), Salzglasur (Steinzeug)', en: 'Tin glaze (faience), salt glaze (stoneware)' },
            firing: { de: 'Hoch (1100‚Äì1400¬∞C)', en: 'High (1100‚Äì1400¬∞C)' },
            temper: { de: 'Sehr fein, industriell aufbereitet', en: 'Very fine, industrially processed' },
            decoration: { de: 'Blaumalerei, Mangan-Dekor, Reliefauflagen, Figuraldekor', en: 'Blue painting, manganese decor, relief, figural decoration' },
            typical_forms: { de: 'Teller, Kr√ºge, Apothekengef√§√üe, Ofenkacheln', en: 'Plates, jugs, pharmacy vessels, stove tiles' },
        },
        color_hints: ['Wei√ü', 'Blau', 'Braun'],
        material_hints: ['Keramik', 'Porzellan'],
        decoration_hints: ['painted', 'figural', 'ornamental'],
    },
    modern: {
        name_de: 'Neuzeit (Industriezeitalter)', name_en: 'Modern (Industrial)',
        period: 'ab 18. Jh.',
        icon: 'üè≠',
        class: 'modern',
        criteria: {
            wall_thickness: { de: 'Sehr d√ºnn (1‚Äì4 mm), gleichm√§√üig', en: 'Very thin (1‚Äì4 mm), uniform' },
            surface: { de: 'Porzellan: glatt, glasiert; Steingut: engobiert', en: 'Porcelain: smooth, glazed; earthenware: slipped' },
            firing: { de: 'Sehr hoch (1200‚Äì1450¬∞C)', en: 'Very high (1200‚Äì1450¬∞C)' },
            temper: { de: 'Kaolin, Feldspat, Quarz (Porzellanmasse)', en: 'Kaolin, feldspar, quartz (porcelain body)' },
            decoration: { de: 'Unterglasurmalerei, Aufglasur, Transfer-Druck, Vergoldung', en: 'Underglaze painting, overglaze, transfer printing, gilding' },
            typical_forms: { de: 'Teller, Tassen, Vasen, industrielle Serienproduktion', en: 'Plates, cups, vases, industrial mass production' },
        },
        color_hints: ['Wei√ü', 'Blau'],
        material_hints: ['Porzellan'],
        decoration_hints: ['painted', 'band', 'figural', 'ornamental'],
    }
};

// ==================================================
// CULTURE CLASSIFICATION
// ==================================================
let selectedCultureOverride = null;

function toggleCultureChip(el) {
    document.querySelectorAll('.culture-chip').forEach(c => c.classList.remove('selected'));
    if (el.classList.contains('selected')) {
        selectedCultureOverride = null;
    } else {
        el.classList.add('selected');
        selectedCultureOverride = el.dataset.culture;
    }
}

function classifyPieceCulture(piece) {
    const scores = {};

    Object.entries(CULTURE_DB).forEach(([key, culture]) => {
        let score = 0;
        const matchedCriteria = [];

        // Color matching
        if (piece.color_name && culture.color_hints.includes(piece.color_name)) {
            score += 25;
            matchedCriteria.push(`color:${piece.color_name}`);
        }

        // Material matching
        if (piece.material && culture.material_hints.includes(piece.material)) {
            score += 20;
            matchedCriteria.push(`material:${piece.material}`);
        }

        // Decoration matching
        if (piece.has_decoration) {
            score += 10;
            matchedCriteria.push('has_decoration');
        }

        // Curvature analysis (thin walls = higher curvature often)
        const curv = piece.curvature || 0;
        if (key === 'roman' || key === 'modern' || key === 'early-modern') {
            if (curv > 0.01) { score += 10; matchedCriteria.push('high_curvature'); }
        } else if (key === 'neolithic') {
            if (curv < 0.005) { score += 10; matchedCriteria.push('low_curvature'); }
        }

        // Area analysis (rough proxy for wall thickness)
        const area = piece.area || 0;
        const bbox = piece.bbox || [0,0,100,100];
        const perimeter = 2 * (bbox[2] + bbox[3]);
        const thickness_proxy = area / (perimeter + 1);

        if (key === 'neolithic' && thickness_proxy > 15) { score += 15; matchedCriteria.push('thick_walls'); }
        if (key === 'roman' && thickness_proxy < 10) { score += 15; matchedCriteria.push('thin_walls'); }
        if (key === 'modern' && thickness_proxy < 8) { score += 15; matchedCriteria.push('very_thin_walls'); }

        // Solidity (regular = wheel-thrown = later periods)
        const sol = piece.solidity || 0;
        if (sol > 0.85 && (key === 'roman' || key === 'medieval' || key === 'modern' || key === 'early-modern')) {
            score += 10; matchedCriteria.push('regular_shape');
        }
        if (sol < 0.7 && (key === 'neolithic' || key === 'bronze-age')) {
            score += 10; matchedCriteria.push('irregular_shape');
        }

        // Circularity
        const circ = piece.circularity || 0;
        if (circ > 0.7 && (key === 'roman' || key === 'modern')) {
            score += 5; matchedCriteria.push('circular');
        }

        scores[key] = { score: Math.min(score, 100), criteria: matchedCriteria };
    });

    // Sort and return top matches
    const sorted = Object.entries(scores)
        .sort((a, b) => b[1].score - a[1].score)
        .filter(([, v]) => v.score > 15);

    return sorted.slice(0, 3);
}

function runCultureClassification() {
    if (activePieces.length === 0) {
        toast(T('upload_first'), 'error');
        return;
    }

    const results = document.getElementById('culture-results');
    const empty = document.getElementById('culture-empty');
    empty.style.display = 'none';

    let html = '';
    const lang = currentLang;

    // Classify each piece
    activePieces.forEach((piece, idx) => {
        let topMatches;

        if (selectedCultureOverride) {
            topMatches = [[selectedCultureOverride, { score: 100, criteria: ['manual_override'] }]];
        } else {
            topMatches = classifyPieceCulture(piece);
        }

        if (topMatches.length === 0) {
            topMatches = [['unknown', { score: 0, criteria: [] }]];
        }

        const topKey = topMatches[0][0];
        const topScore = topMatches[0][1].score;
        const topCriteria = topMatches[0][1].criteria;
        const culture = CULTURE_DB[topKey] || { name_de: 'Unbestimmt', name_en: 'Undetermined', icon: '‚ùì', class: 'unknown', period: '?', criteria: {} };

        html += `<div class="culture-card ${culture.class}">
            <div class="culture-header">
                <div style="display:flex;align-items:center;gap:12px;">
                    ${piece.thumbnailDataUrl ? `<img src="${piece.thumbnailDataUrl}" style="width:50px;height:50px;object-fit:cover;border-radius:8px;">` : ''}
                    <div>
                        <div class="culture-title">${piece.id.substring(0,11)}</div>
                        <div style="font-size:12px;color:var(--text-muted);">${piece.name || 'Fragment'}</div>
                    </div>
                </div>
                <div>
                    <span class="culture-badge ${culture.class}">${culture.icon} ${lang === 'de' ? culture.name_de : culture.name_en}</span>
                    <div class="culture-confidence">${T('culture_confidence')}: ${topScore}%</div>
                </div>
            </div>

            <div class="culture-details">
                <div class="culture-detail">
                    <div class="culture-detail-label">‚è≥ ${lang === 'de' ? 'Zeitraum' : 'Period'}</div>
                    <div class="culture-detail-value">${culture.period}</div>
                </div>
                <div class="culture-detail">
                    <div class="culture-detail-label">üé® ${T('culture_decoration')}</div>
                    <div class="culture-detail-value">${culture.criteria.decoration ? (lang === 'de' ? culture.criteria.decoration.de : culture.criteria.decoration.en) : '-'}</div>
                </div>
                <div class="culture-detail">
                    <div class="culture-detail-label">üî• ${T('culture_firing')}</div>
                    <div class="culture-detail-value">${culture.criteria.firing ? (lang === 'de' ? culture.criteria.firing.de : culture.criteria.firing.en) : '-'}</div>
                </div>
                <div class="culture-detail">
                    <div class="culture-detail-label">üìê ${T('culture_wall_thickness')}</div>
                    <div class="culture-detail-value">${culture.criteria.wall_thickness ? (lang === 'de' ? culture.criteria.wall_thickness.de : culture.criteria.wall_thickness.en) : '-'}</div>
                </div>
            </div>

            <div class="culture-criteria">
                <h5>${T('culture_criteria_used')}</h5>
                <ul>
                    ${topCriteria.map(c => `<li class="match">‚úì ${c.replace(/_/g,' ')}</li>`).join('')}
                </ul>
                ${topMatches.length > 1 ? `<p style="margin-top:8px;font-size:11px;color:var(--text-muted);">
                    ${lang === 'de' ? 'Weitere M√∂glichkeiten' : 'Other possibilities'}: 
                    ${topMatches.slice(1).map(([k, v]) => {
                        const c = CULTURE_DB[k];
                        return c ? `${c.icon} ${lang === 'de' ? c.name_de : c.name_en} (${v.score}%)` : '';
                    }).filter(Boolean).join(', ')}
                </p>` : ''}
            </div>
        </div>`;
    });

    results.innerHTML = html;

    // Render knowledge base
    renderCultureKnowledgeBase();
}

function renderCultureKnowledgeBase() {
    const container = document.getElementById('culture-kb-content');
    const lang = currentLang;
    let html = '';

    Object.entries(CULTURE_DB).forEach(([key, culture]) => {
        html += `<div class="culture-card ${culture.class}" style="padding:16px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                <span style="font-size:16px;font-weight:600;">${culture.icon} ${lang === 'de' ? culture.name_de : culture.name_en}</span>
                <span style="font-size:12px;color:var(--text-muted);">${culture.period}</span>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                ${Object.entries(culture.criteria).map(([ck, cv]) => `
                    <div style="padding:6px 10px;background:var(--bg-secondary);border-radius:6px;">
                        <div style="font-size:10px;color:var(--text-muted);text-transform:uppercase;">${T('culture_' + ck) || ck}</div>
                        <div style="font-size:12px;color:var(--text-secondary);">${lang === 'de' ? cv.de : cv.en}</div>
                    </div>
                `).join('')}
            </div>
        </div>`;
    });

    container.innerHTML = html;
}

// ==================================================
// DECORATION ‚Üí LINE DRAWING
// ==================================================
let selectedDecoFragment = null;
let decoOriginalImg = null;
let decoLineArtImg = null;
let decoSvgData = null;

function renderDecoSelection() {
    const grid = document.getElementById('deco-select-grid');
    const empty = document.getElementById('deco-empty');
    const main = document.getElementById('deco-main');

    // Show all pieces, highlight decorated ones
    const decorated = activePieces.filter(p => p.has_decoration);
    const all = activePieces;

    if (all.length === 0) {
        empty.style.display = '';
        main.style.display = 'none';
        return;
    }

    empty.style.display = 'none';
    main.style.display = '';

    let html = '';
    all.forEach((p, idx) => {
        const isDeco = p.has_decoration;
        html += `<div class="deco-select-item ${selectedDecoFragment === idx ? 'selected' : ''}" 
                     onclick="selectDecoFragment(${idx})"
                     style="${isDeco ? 'border-color:var(--accent);' : ''}">
            ${p.thumbnailDataUrl ? `<img src="${p.thumbnailDataUrl}">` : '<div style="width:100%;aspect-ratio:1;background:var(--bg-secondary);border-radius:6px;"></div>'}
            <div class="deco-id">${p.id.substring(0,8)} ${isDeco ? 'üé®' : ''}</div>
        </div>`;
    });
    grid.innerHTML = html;
}

function selectDecoFragment(idx) {
    selectedDecoFragment = idx;
    document.querySelectorAll('.deco-select-item').forEach((el, i) => {
        el.classList.toggle('selected', i === idx);
    });
}

async function runDecoExtraction() {
    if (selectedDecoFragment === null || !activePieces[selectedDecoFragment]) {
        toast(currentLang === 'de' ? 'Bitte erst ein Fragment w√§hlen' : 'Please select a fragment first', 'error');
        return;
    }

    if (!pyReady || !window.py_extract_decoration) {
        toast(currentLang === 'de'
            ? 'Python-Umgebung noch nicht bereit. Bitte warten.'
            : 'Python environment not ready yet. Please wait.', 'error');
        return;
    }

    const piece = activePieces[selectedDecoFragment];
    const lineThickness = parseInt(document.getElementById('slider-line-thickness').value);
    const detailLevel = parseInt(document.getElementById('slider-detail-level').value);
    const edgeSensitivity = parseInt(document.getElementById('slider-edge-sensitivity').value);
    const decoType = document.getElementById('select-deco-type').value;

    toast(currentLang === 'de' ? 'Extrahiere Verzierung...' : 'Extracting decoration...', 'info');

    try {
        const result = window.py_extract_decoration(
            piece.thumbnailDataUrl,
            lineThickness,
            detailLevel,
            edgeSensitivity,
            decoType
        );

        let data;
        if (result && typeof result.toJs === 'function') {
            data = result.toJs({dict_converter: Object.fromEntries});
        } else {
            data = result;
        }

        if (data && data.lineartDataUrl) {
            decoOriginalImg = piece.thumbnailDataUrl;
            decoLineArtImg = data.lineartDataUrl;
            decoSvgData = data.svgData || null;

            // Draw original
            const canvasOrig = document.getElementById('deco-canvas-original');
            const ctxOrig = canvasOrig.getContext('2d');
            const imgOrig = new Image();
            imgOrig.onload = () => {
                canvasOrig.width = imgOrig.width;
                canvasOrig.height = imgOrig.height;
                ctxOrig.drawImage(imgOrig, 0, 0);
            };
            imgOrig.src = decoOriginalImg;

            // Draw line art
            const canvasLine = document.getElementById('deco-canvas-lineart');
            const ctxLine = canvasLine.getContext('2d');
            const imgLine = new Image();
            imgLine.onload = () => {
                canvasLine.width = imgLine.width;
                canvasLine.height = imgLine.height;
                ctxLine.drawImage(imgLine, 0, 0);
            };
            imgLine.src = decoLineArtImg;

            // Scale info
            const dims = data.dimensions || {};
            document.getElementById('deco-scale-info').textContent = `1:1 (${dims.ppmm ? dims.ppmm.toFixed(1) + ' px/mm' : 'auto'})`;
            document.getElementById('deco-dimensions').textContent = `${dims.width_mm ? dims.width_mm.toFixed(0) : '?'} √ó ${dims.height_mm ? dims.height_mm.toFixed(0) : '?'} mm`;

            document.getElementById('deco-result').style.display = '';
            updateDecoOverlay();

            toast(currentLang === 'de' ? 'Strichzeichnung erstellt!' : 'Line drawing created!', 'success');
        }
    } catch (err) {
        console.error('Decoration extraction error:', err);
        toast('Error: ' + err.message, 'error');
    }
}

let overlayMode = 'lines';
function toggleOverlayMode(el, mode) {
    overlayMode = mode;
    document.querySelectorAll('.deco-overlay-toggle').forEach(t => t.classList.remove('active'));
    el.classList.add('active');
    updateDecoOverlay();
}

function updateDecoOverlay() {
    if (!decoOriginalImg || !decoLineArtImg) return;
    const canvas = document.getElementById('deco-canvas-overlay');
    const ctx = canvas.getContext('2d');
    const opacity = parseInt(document.getElementById('slider-overlay-opacity').value) / 100;

    const imgA = new Image();
    const imgB = new Image();

    const base = overlayMode === 'lines' ? decoOriginalImg : decoLineArtImg;
    const overlay = overlayMode === 'lines' ? decoLineArtImg : decoOriginalImg;

    imgA.onload = () => {
        canvas.width = imgA.width;
        canvas.height = imgA.height;
        ctx.drawImage(imgA, 0, 0);
        imgB.onload = () => {
            ctx.globalAlpha = opacity;
            ctx.drawImage(imgB, 0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;
        };
        imgB.src = overlay;
    };
    imgA.src = base;
}

function downloadDecoImage(type) {
    let canvas;
    if (type === 'lineart') canvas = document.getElementById('deco-canvas-lineart');
    else if (type === 'overlay') canvas = document.getElementById('deco-canvas-overlay');
    else return;

    const link = document.createElement('a');
    link.download = `shardmind_${type}_${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

function downloadDecoSVG() {
    if (!decoSvgData) {
        toast('No SVG data available', 'error');
        return;
    }
    const blob = new Blob([decoSvgData], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.download = `shardmind_decoration_${Date.now()}.svg`;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
}

// ==================================================
// INIT
// ==================================================
function init() {
    currentLang = localStorage.getItem('shardmind_lang') || 'de';
    setLanguage(currentLang);
    checkCookieConsent();
    
    // Hide loading screen after brief splash (don't block on Python)
    setTimeout(() => {
        const ls = document.getElementById('loading-screen');
        if (ls) ls.classList.add('hidden');
    }, 1500);
    
    // Auto-login if saved
    const savedUser = localStorage.getItem('shardmind_user');
    if (savedUser) {
        const db = getDB();
        if (db[savedUser]) {
            currentUser = savedUser;
            showApp();
        } else {
            document.getElementById('login-page').style.display = '';
        }
    } else {
        document.getElementById('login-page').style.display = '';
    }
    
    // Start monitoring Python environment
    monitorPythonLoading();
}

// ==================================================
// PYTHON ENVIRONMENT MONITORING
// ==================================================

let pyLoadStartTime = Date.now();
let pyLoadTimeout = null;
let pyMonitorInterval = null;
const PY_TIMEOUT_MS = 120000; // 120 seconds

function monitorPythonLoading() {
    pyLoadStartTime = Date.now();
    
    // Poll for pyReady every 500ms
    pyMonitorInterval = setInterval(() => {
        const elapsed = Date.now() - pyLoadStartTime;
        const elapsedSec = Math.round(elapsed / 1000);
        
        if (pyReady || window.py_analyze) {
            // Python is ready!
            pyReady = true;
            clearInterval(pyMonitorInterval);
            setPyStatus('ready', currentLang === 'de' ? '‚úì Python-Engine bereit' : '‚úì Python engine ready');
            return;
        }
        
        if (elapsed > PY_TIMEOUT_MS) {
            // Timeout
            clearInterval(pyMonitorInterval);
            setPyStatus('error', currentLang === 'de' 
                ? `Zeit√ºberschreitung (${elapsedSec}s). Pakete konnten nicht geladen werden.`
                : `Timeout (${elapsedSec}s). Packages could not be loaded.`);
            return;
        }
        
        // Still loading - update status with elapsed time
        const statusText = currentLang === 'de'
            ? `Python-Engine l√§dt... (${elapsedSec}s)`
            : `Python engine loading... (${elapsedSec}s)`;
        
        const statusEl = document.getElementById('py-status-text');
        if (statusEl) statusEl.textContent = statusText;
        
        // Also update loading screen text if still visible
        const loadingPkg = document.getElementById('loading-packages');
        if (loadingPkg) loadingPkg.textContent = statusText;
        
    }, 500);
    
    // Listen for PyScript errors
    window.addEventListener('error', (e) => {
        if (e.message && (e.message.includes('pyodide') || e.message.includes('pyscript') || e.message.includes('micropip'))) {
            clearInterval(pyMonitorInterval);
            setPyStatus('error', currentLang === 'de' 
                ? `Fehler beim Laden: ${e.message.substring(0, 80)}`
                : `Load error: ${e.message.substring(0, 80)}`);
        }
    });
    
    // Listen for unhandled promise rejections (common with PyScript)
    window.addEventListener('unhandledrejection', (e) => {
        const reason = e.reason ? String(e.reason).substring(0, 100) : 'Unknown error';
        if (reason.includes('pyodide') || reason.includes('pyscript') || reason.includes('micropip') || reason.includes('Package')) {
            clearInterval(pyMonitorInterval);
            console.error('PyScript load error:', reason);
            setPyStatus('error', currentLang === 'de'
                ? `Paket-Fehler: ${reason.substring(0, 60)}`
                : `Package error: ${reason.substring(0, 60)}`);
        }
    });
}

function setPyStatus(state, text) {
    const bar = document.getElementById('py-status-bar');
    const textEl = document.getElementById('py-status-text');
    const retryBtn = document.getElementById('py-retry-btn');
    
    if (!bar) return;
    
    bar.className = 'py-status-bar ' + state;
    if (textEl) textEl.textContent = text;
    
    if (state === 'error') {
        retryBtn.style.display = '';
    } else if (state === 'ready') {
        retryBtn.style.display = 'none';
        // Auto-hide after 5 seconds on success
        setTimeout(() => {
            bar.style.transition = 'opacity 0.5s, max-height 0.5s';
            bar.style.opacity = '0';
            bar.style.maxHeight = '0';
            bar.style.padding = '0';
            bar.style.margin = '0';
            bar.style.overflow = 'hidden';
        }, 5000);
    } else {
        retryBtn.style.display = 'none';
    }
}

function retryPyLoad() {
    setPyStatus('loading', currentLang === 'de' ? 'Neustart...' : 'Restarting...');
    toast(currentLang === 'de' ? 'Seite wird neu geladen...' : 'Reloading page...', 'info');
    setTimeout(() => location.reload(), 800);
}

// Wait for DOM
document.addEventListener('DOMContentLoaded', init);
</script>

<!-- ======================= PYSCRIPT - PYTHON CODE ======================= -->
<script type="py" config='{"packages":["numpy","opencv-python","scikit-learn","scipy","Pillow"]}'>
import js
import sys

def update_loading(msg):
    """Update both loading screen and sidebar status"""
    try:
        el = js.document.getElementById('loading-packages')
        if el:
            el.textContent = msg
        el2 = js.document.getElementById('py-status-text')
        if el2:
            el2.textContent = msg
    except:
        pass
    print(f"[ShardMind] {msg}")

def set_py_ready():
    """Signal to JavaScript that Python engine is ready"""
    js.pyReady = True
    # Hide loading screen
    loading = js.document.getElementById('loading-screen')
    if loading:
        loading.classList.add('hidden')
    # Update sidebar status
    try:
        if js.window.setPyStatus:
            lang = js.window.currentLang or 'de'
            msg = '‚úì Python-Engine bereit' if lang == 'de' else '‚úì Python engine ready'
            js.window.setPyStatus('ready', msg)
    except:
        pass

def set_py_error(msg):
    """Signal to JavaScript that Python loading failed"""
    try:
        if js.window.setPyStatus:
            js.window.setPyStatus('error', msg)
    except:
        pass
    # Still hide loading screen so app is usable
    loading = js.document.getElementById('loading-screen')
    if loading:
        loading.classList.add('hidden')

# =============================================================================
# IMPORT PACKAGES WITH PROGRESS
# =============================================================================

try:
    update_loading("Loading NumPy...")
    import numpy as np
    
    update_loading("Loading OpenCV...")
    import cv2
    
    update_loading("Loading scikit-learn...")
    from sklearn.cluster import AgglomerativeClustering
    
    update_loading("Loading SciPy...")
    from scipy.spatial.distance import cdist
    
    update_loading("Loading Pillow...")
    from PIL import Image
    
    update_loading("Loading utilities...")
    from pyodide.ffi import to_js, create_proxy
    import json
    import base64
    from io import BytesIO
    import uuid
    
    update_loading("Alle Pakete geladen ‚úì")

except Exception as e:
    error_msg = f"Import-Fehler: {str(e)[:100]}"
    print(f"[ShardMind ERROR] {error_msg}")
    update_loading(error_msg)
    set_py_error(error_msg)
    raise  # re-raise so we don't execute code that depends on these imports

# =============================================================================
# HELPER: Convert images between JS and Python
# =============================================================================

def uint8_to_cv2(uint8_array):
    """Convert JS Uint8Array to OpenCV image"""
    buf = bytes(uint8_array)
    nparr = np.frombuffer(buf, np.uint8)
    img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    return img

def cv2_to_dataurl(img):
    """Convert OpenCV image to data URL"""
    rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    pil = Image.fromarray(rgb)
    buf = BytesIO()
    pil.save(buf, format='PNG')
    b64 = base64.b64encode(buf.getvalue()).decode()
    return f"data:image/png;base64,{b64}"

def gen_id():
    return f"SM-{uuid.uuid4().hex[:8].upper()}"

# =============================================================================
# FRAGMENT DETECTION (full port from Streamlit version)
# =============================================================================

def separate_touching_fragments(mask, min_area=100, separation_strength=0.5):
    if mask is None or cv2.countNonZero(mask) == 0:
        return mask
    
    dist = cv2.distanceTransform(mask, cv2.DIST_L2, 5)
    dist_norm = cv2.normalize(dist, None, 0, 1.0, cv2.NORM_MINMAX)
    threshold = 0.6 - (separation_strength * 0.4)
    _, sure_fg = cv2.threshold(dist_norm, threshold, 1.0, cv2.THRESH_BINARY)
    sure_fg = np.uint8(sure_fg * 255)
    
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    sure_bg = cv2.dilate(mask, kernel, iterations=3)
    unknown = cv2.subtract(sure_bg, sure_fg)
    
    _, markers = cv2.connectedComponents(sure_fg)
    markers = markers + 1
    markers[unknown == 255] = 0
    
    mask_color = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)
    markers = cv2.watershed(mask_color, markers)
    
    separated = np.zeros_like(mask)
    separated[markers > 1] = 255
    separated[markers == -1] = 0
    return separated


def segment_fragments(image, min_area=100, project="", mode="auto", separation_strength=0.5):
    h, w = image.shape[:2]
    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    gray = cv2.cvtColor(blurred, cv2.COLOR_BGR2GRAY)
    lab = cv2.cvtColor(blurred, cv2.COLOR_BGR2Lab)
    
    masks = []
    
    if mode in ["auto", "light_bg", "porcelain"]:
        adapt = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 25, 8)
        masks.append(adapt)
        _, otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        masks.append(otsu)
        l_ch = lab[:, :, 0]
        _, lab_th = cv2.threshold(l_ch, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        masks.append(lab_th)
    
    if mode in ["auto", "dark_bg"]:
        _, inv = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        masks.append(inv)
    
    if mode in ["porcelain"]:
        margin = 30
        corners = [
            gray[margin:2*margin, margin:2*margin],
            gray[margin:2*margin, w-2*margin:w-margin],
            gray[h-2*margin:h-margin, margin:2*margin],
            gray[h-2*margin:h-margin, w-2*margin:w-margin]
        ]
        bg_mean = np.mean([c.mean() for c in corners if c.size > 0])
        bg_std = np.mean([c.std() for c in corners if c.size > 0])
        
        shadow_thresh = bg_mean - 20 - bg_std
        shadow_mask = (gray < shadow_thresh).astype(np.uint8) * 255
        masks.append(shadow_mask)
        
        l_channel = lab[:, :, 0]
        l_thresh = np.percentile(l_channel, 15)
        l_mask = (l_channel < l_thresh).astype(np.uint8) * 255
        masks.append(l_mask)
        
        hsv = cv2.cvtColor(blurred, cv2.COLOR_BGR2HSV)
        blue_mask = cv2.inRange(hsv, np.array([90, 25, 40]), np.array([130, 255, 255]))
        green_mask = cv2.inRange(hsv, np.array([35, 25, 40]), np.array([85, 255, 255]))
        sat_mask = (hsv[:, :, 1] > 30).astype(np.uint8) * 255
        color_mask = cv2.bitwise_or(blue_mask, green_mask)
        color_mask = cv2.bitwise_or(color_mask, sat_mask)
        kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (25, 25))
        color_expanded = cv2.dilate(color_mask, kernel_dilate, iterations=2)
        masks.append(color_expanded)
    
    if mode in ["auto", "high_contrast"]:
        edges = cv2.Canny(gray, 30, 100)
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7))
        edges = cv2.dilate(edges, kernel, iterations=3)
        contours_e, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        edge_mask = np.zeros_like(gray)
        cv2.drawContours(edge_mask, contours_e, -1, 255, -1)
        masks.append(edge_mask)
        
        corners_img = [image[0:30, 0:30], image[0:30, w-30:w], image[h-30:h, 0:30], image[h-30:h, w-30:w]]
        bg_colors = np.vstack([c.reshape(-1, 3) for c in corners_img if c.size > 0])
        bg_mean_c = np.mean(bg_colors, axis=0)
        bg_std_c = np.std(bg_colors, axis=0) + 15
        diff = np.abs(image.astype(float) - bg_mean_c)
        fg_mask = np.any(diff > bg_std_c * 2, axis=2).astype(np.uint8) * 255
        masks.append(fg_mask)
    
    combined = np.zeros_like(gray)
    for m in masks:
        combined = cv2.bitwise_or(combined, m)
    
    kernel_close = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7))
    kernel_open = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    cleaned = cv2.morphologyEx(combined, cv2.MORPH_CLOSE, kernel_close, iterations=2)
    cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_OPEN, kernel_open, iterations=1)
    cleaned = separate_touching_fragments(cleaned, min_area, separation_strength)
    
    kernel_clean = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_OPEN, kernel_clean, iterations=1)
    cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_CLOSE, kernel_clean, iterations=1)
    
    border = 10
    cleaned[:border, :] = 0
    cleaned[-border:, :] = 0
    cleaned[:, :border] = 0
    cleaned[:, -border:] = 0
    
    contours, _ = cv2.findContours(cleaned, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    pieces = []
    max_area = h * w * 0.6
    
    for c in contours:
        area = cv2.contourArea(c)
        if area < min_area or area > max_area:
            continue
        
        x, y, bw, bh = cv2.boundingRect(c)
        aspect = bw / (bh + 1e-6)
        if aspect < 0.15 or aspect > 7:
            continue
        
        hull = cv2.convexHull(c)
        hull_area = cv2.contourArea(hull)
        if hull_area > 0:
            solidity = area / hull_area
            if solidity < 0.35:
                continue
        
        mg = 10
        x1, y1 = max(0, x - mg), max(0, y - mg)
        x2, y2 = min(w, x + bw + mg), min(h, y + bh + mg)
        
        roi = image[y1:y2, x1:x2].copy()
        piece_mask = np.zeros((h, w), dtype=np.uint8)
        cv2.drawContours(piece_mask, [c], -1, 255, -1)
        mask_roi = piece_mask[y1:y2, x1:x2].copy()
        
        contour_rel = c.copy()
        contour_rel[:, :, 0] -= x1
        contour_rel[:, :, 1] -= y1
        
        M = cv2.moments(c)
        cx = int(M['m10'] / M['m00']) if M['m00'] > 0 else x + bw // 2
        cy = int(M['m01'] / M['m00']) if M['m00'] > 0 else y + bh // 2
        
        # Auto-classify
        hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
        mean_hsv = cv2.mean(hsv, mask=mask_roi)
        h_val, s_val, v_val = mean_hsv[:3]
        
        if s_val < 25:
            color_name = "Wei√ü" if v_val > 180 else ("Grau" if v_val > 100 else "Schwarz")
        elif h_val < 10 or h_val > 170: color_name = "Rot"
        elif h_val < 25: color_name = "Orange"
        elif h_val < 40: color_name = "Braun"
        elif h_val < 80: color_name = "Gr√ºn"
        elif h_val < 130: color_name = "Blau"
        else: color_name = "Violett"
        
        if s_val < 20 and v_val > 200: material = "Porzellan"
        elif 10 < h_val < 35 and s_val > 30: material = "Keramik"
        elif s_val < 25 and v_val < 100: material = "Metall"
        else: material = "Keramik"
        
        name = f"{material}_{color_name}"
        
        # Decoration analysis
        sat = hsv[:, :, 1]
        colored_mask = (sat > 30) & (mask_roi > 0)
        total_px = np.sum(mask_roi > 0)
        has_decoration = (np.sum(colored_mask) / max(total_px, 1)) > 0.05 if total_px > 0 else False
        
        # Curvature
        pts = c.reshape(-1, 2).astype(float)
        n_pts = len(pts)
        curvatures = []
        step = max(1, n_pts // 20)
        for ii in range(0, n_pts, step):
            p_prev = pts[(ii - step) % n_pts]
            p_curr = pts[ii]
            p_next = pts[(ii + step) % n_pts]
            v1 = p_curr - p_prev
            v2 = p_next - p_curr
            cross = abs(v1[0] * v2[1] - v1[1] * v2[0])
            l1 = np.linalg.norm(v1)
            l2 = np.linalg.norm(v2)
            if l1 > 0 and l2 > 0:
                curvatures.append(cross / (l1 * l2 * (l1 + l2) / 2 + 1e-9))
        curvature = float(np.median(curvatures)) if curvatures else 0.0
        
        # Thumbnail as data URL
        thumb_url = cv2_to_dataurl(roi)
        
        # Features for clustering
        lab_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2Lab)
        lab_mean, lab_std = cv2.meanStdDev(lab_roi, mask=mask_roi)
        color_feat = np.concatenate([lab_mean.flatten(), lab_std.flatten()])
        
        hull_c = cv2.convexHull(contour_rel)
        hull_area_c = cv2.contourArea(hull_c)
        solidity_f = area / (hull_area_c + 1) if hull_area_c > 0 else 0
        perimeter = cv2.arcLength(contour_rel, True)
        circularity_f = 4 * np.pi * area / (perimeter ** 2 + 1)
        
        piece_data = {
            'id': gen_id(),
            'name': name,
            'material': material,
            'color_name': color_name,
            'area': float(area),
            'centroid': [int(cx), int(cy)],
            'bbox': [int(x), int(y), int(bw), int(bh)],
            'excavation': project,
            'has_decoration': bool(has_decoration),
            'curvature': curvature,
            'is_edge_piece': has_decoration or curvature > 0.005,
            'thumbnailDataUrl': thumb_url,
            'color_features': color_feat.tolist(),
            'solidity': float(solidity_f),
            'circularity': float(circularity_f),
            # Store contour and offset for reconstruction
            'contour_global': c.tolist(),
            'offset': [int(x1), int(y1)],
            'thumbnail_shape': [int(roi.shape[0]), int(roi.shape[1])],
        }
        
        pieces.append(piece_data)
    
    return pieces


# =============================================================================
# CLUSTERING
# =============================================================================

def calc_similarity(p1, p2):
    score = 0
    
    c1 = np.array(p1.get('color_features', []))
    c2 = np.array(p2.get('color_features', []))
    if len(c1) > 0 and len(c2) > 0:
        dist = np.linalg.norm(c1 - c2)
        score += max(0, 100 - dist * 2) * 0.4
    
    if p1.get('material') == p2.get('material'):
        score += 30
    
    a1, a2 = p1.get('area', 0), p2.get('area', 0)
    if a1 > 0 and a2 > 0:
        ratio = min(a1, a2) / max(a1, a2)
        score += ratio * 20
    
    sol_diff = abs(p1.get('solidity', 0) - p2.get('solidity', 0))
    score += max(0, 10 - sol_diff * 20)
    
    return score


def cluster_pieces(pieces, threshold=35):
    n = len(pieces)
    if n < 2:
        return [0] if n == 1 else []
    
    sim = np.zeros((n, n))
    for i in range(n):
        for j in range(i + 1, n):
            s = calc_similarity(pieces[i], pieces[j])
            sim[i, j] = sim[j, i] = s
    
    dist = 100 - sim
    np.fill_diagonal(dist, 0)
    
    try:
        cl = AgglomerativeClustering(
            n_clusters=None,
            distance_threshold=100 - threshold,
            metric='precomputed',
            linkage='average'
        )
        labels = cl.fit_predict(dist)
        return labels.tolist()
    except:
        return [0] * n


# =============================================================================
# RECONSTRUCTION (Circle-fitting)
# =============================================================================

def reconstruct_group(pieces_data, canvas_size=800):
    """Reconstruct using circle fitting from blue decoration band"""
    n = len(pieces_data)
    canvas = np.ones((canvas_size, canvas_size, 3), dtype=np.uint8) * 245
    canvas_center = canvas_size // 2
    target_radius = canvas_size * 0.42
    
    # Collect blue points from all pieces
    all_blue_points = []
    piece_images = []
    
    for p in pieces_data:
        # Decode thumbnail from data URL
        data_url = p.get('thumbnailDataUrl', '')
        if not data_url:
            piece_images.append(None)
            continue
        
        try:
            b64_data = data_url.split(',')[1]
            img_bytes = base64.b64decode(b64_data)
            nparr = np.frombuffer(img_bytes, np.uint8)
            thumb = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            piece_images.append(thumb)
        except:
            piece_images.append(None)
            continue
        
        if thumb is None:
            continue
        
        offset = p.get('offset', [0, 0])
        hsv = cv2.cvtColor(thumb, cv2.COLOR_BGR2HSV)
        h_ch = hsv[:, :, 0]
        s_ch = hsv[:, :, 1]
        blue_mask = ((h_ch > 90) & (h_ch < 130) & (s_ch > 35))
        
        local_pts = np.column_stack(np.where(blue_mask))[:, ::-1]
        if len(local_pts) > 0:
            global_pts = local_pts + np.array([offset[0], offset[1]])
            all_blue_points.extend(global_pts.tolist())
    
    all_blue_points = np.array(all_blue_points) if all_blue_points else np.array([])
    
    # Circle fitting
    plate_cx, plate_cy, plate_r = None, None, None
    
    if len(all_blue_points) > 50:
        x = all_blue_points[:, 0].astype(float)
        y = all_blue_points[:, 1].astype(float)
        A = np.column_stack([x, y, np.ones_like(x)])
        b = x**2 + y**2
        try:
            result, _, _, _ = np.linalg.lstsq(A, b, rcond=None)
            plate_cx = result[0] / 2
            plate_cy = result[1] / 2
            plate_r = np.sqrt(max(0, result[2] + plate_cx**2 + plate_cy**2))
        except:
            pass
    
    if plate_cx is None or plate_r is None or plate_r < 10:
        centroids = [p['centroid'] for p in pieces_data if 'centroid' in p]
        if centroids:
            plate_cx = np.mean([c[0] for c in centroids])
            plate_cy = np.mean([c[1] for c in centroids])
            plate_r = 200
        else:
            plate_cx, plate_cy, plate_r = canvas_center, canvas_center, 200
    
    scale = target_radius / plate_r if plate_r > 0 else 0.5
    scale = np.clip(scale, 0.2, 2.0)
    
    # Place each piece
    for idx, p in enumerate(pieces_data):
        thumb = piece_images[idx] if idx < len(piece_images) else None
        if thumb is None:
            continue
        
        offset = p.get('offset', [0, 0])
        h_t, w_t = thumb.shape[:2]
        
        nw = max(1, int(w_t * scale))
        nh = max(1, int(h_t * scale))
        
        thumb_s = cv2.resize(thumb, (nw, nh))
        
        # Calculate position
        rel_cx = (plate_cx - offset[0]) * scale
        rel_cy = (plate_cy - offset[1]) * scale
        px = int(canvas_center - rel_cx)
        py = int(canvas_center - rel_cy)
        
        # Blend onto canvas
        dx1 = max(0, px)
        dy1 = max(0, py)
        dx2 = min(canvas_size, px + nw)
        dy2 = min(canvas_size, py + nh)
        sx1 = dx1 - px
        sy1 = dy1 - py
        
        if dx2 > dx1 and dy2 > dy1:
            t_h, t_w = dy2 - dy1, dx2 - dx1
            if sy1 + t_h <= thumb_s.shape[0] and sx1 + t_w <= thumb_s.shape[1]:
                roi = canvas[dy1:dy2, dx1:dx2]
                t_roi = thumb_s[sy1:sy1 + t_h, sx1:sx1 + t_w]
                
                if roi.shape[:2] == t_roi.shape[:2]:
                    # Simple mask based on non-white pixels
                    gray_t = cv2.cvtColor(t_roi, cv2.COLOR_BGR2GRAY)
                    _, mask = cv2.threshold(gray_t, 240, 255, cv2.THRESH_BINARY_INV)
                    mask_3ch = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR).astype(float) / 255
                    blended = t_roi.astype(float) * mask_3ch + roi.astype(float) * (1 - mask_3ch)
                    canvas[dy1:dy2, dx1:dx2] = blended.astype(np.uint8)
    
    # Draw circle
    cv2.circle(canvas, (canvas_center, canvas_center), int(target_radius), (230, 225, 220), 2)
    
    return canvas


# =============================================================================
# EDGE MATCHING (for match display)
# =============================================================================

def extract_edge_signature(contour_list, num_points=64):
    contour = np.array(contour_list).reshape(-1, 2).astype(float)
    if len(contour) < 5:
        return None
    
    diffs = np.diff(contour, axis=0)
    lengths = np.sqrt((diffs ** 2).sum(axis=1))
    cumlen = np.concatenate([[0], np.cumsum(lengths)])
    total_len = cumlen[-1]
    
    if total_len < 1:
        return None
    
    target_lens = np.linspace(0, total_len, num_points)
    resampled = np.zeros((num_points, 2))
    
    for i, target in enumerate(target_lens):
        idx = np.searchsorted(cumlen, target)
        idx = min(idx, len(cumlen) - 1)
        if idx == 0:
            resampled[i] = contour[0]
        else:
            t = (target - cumlen[idx - 1]) / (cumlen[idx] - cumlen[idx - 1] + 1e-6)
            resampled[i] = contour[idx - 1] + t * (contour[idx] - contour[idx - 1])
    
    curvature = np.zeros(num_points)
    for i in range(num_points):
        p_prev = resampled[(i - 2) % num_points]
        p_curr = resampled[i]
        p_next = resampled[(i + 2) % num_points]
        v1 = p_curr - p_prev
        v2 = p_next - p_curr
        cross = v1[0] * v2[1] - v1[1] * v2[0]
        dot = v1[0] * v2[0] + v1[1] * v2[1]
        curvature[i] = np.arctan2(cross, dot + 1e-6)
    
    return curvature


def find_edge_matches(pieces_data, min_match_score=0.3):
    n = len(pieces_data)
    matches = []
    
    sigs = []
    for p in pieces_data:
        contour = p.get('contour_global')
        if contour:
            sig = extract_edge_signature(contour)
        else:
            sig = None
        sigs.append(sig)
    
    for i in range(n):
        if sigs[i] is None:
            continue
        for j in range(i + 1, n):
            if sigs[j] is None:
                continue
            
            best_score = 0
            best_rotation = 0
            curv_i = sigs[i]
            curv_j = sigs[j]
            num_pts = len(curv_i)
            
            for rot in range(0, num_pts, num_pts // 8):
                curv_j_rot = np.roll(-curv_j[::-1], rot)
                correlation = np.correlate(curv_i, curv_j_rot, mode='same')
                max_corr = np.max(correlation)
                if max_corr > best_score:
                    best_score = max_corr
                    best_rotation = rot
            
            score = best_score / (num_pts * np.pi)
            
            c1 = np.array(pieces_data[i].get('color_features', []))
            c2 = np.array(pieces_data[j].get('color_features', []))
            if len(c1) > 0 and len(c2) > 0:
                color_dist = np.linalg.norm(c1 - c2)
                score += max(0, 0.3 - color_dist / 500)
            
            if score > min_match_score:
                matches.append({
                    'piece_i': i,
                    'piece_j': j,
                    'score': score * 100,
                    'rotation': best_rotation * 360 / num_pts
                })
    
    matches.sort(key=lambda x: x['score'], reverse=True)
    return matches


# =============================================================================
# EXPOSED FUNCTIONS (called from JavaScript)
# =============================================================================

def py_analyze(uint8_data, min_area, mode, separation, project):
    """Main analysis function called from JS"""
    # Convert Uint8Array to numpy
    buf = bytes(uint8_data)
    nparr = np.frombuffer(buf, np.uint8)
    img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    
    if img is None:
        return to_js([])
    
    pieces = segment_fragments(img, min_area, project, mode, separation)
    return to_js(pieces, dict_converter=js.Object.fromEntries)

def py_cluster(pieces_json, threshold):
    """Clustering function called from JS"""
    pieces = pieces_json.to_py()
    labels = cluster_pieces(pieces, threshold)
    return to_js(labels)

def py_reconstruct(pieces_json, canvas_size):
    """Reconstruction function called from JS"""
    pieces = pieces_json.to_py()
    
    canvas = reconstruct_group(pieces, canvas_size)
    
    if canvas is None:
        return to_js({'imageDataUrl': None, 'matches': []})
    
    data_url = cv2_to_dataurl(canvas)
    
    # Edge matches
    matches = find_edge_matches(pieces)
    
    return to_js({
        'imageDataUrl': data_url,
        'matches': matches[:10]
    }, dict_converter=js.Object.fromEntries)



# =============================================================================
# DECORATION ‚Üí LINE DRAWING EXTRACTION
# =============================================================================

def extract_decoration_lineart(data_url, line_thickness=2, detail_level=50, edge_sensitivity=50, deco_type="auto"):
    """
    Extract decoration from a fragment photo and create a scaled line drawing.
    
    Process:
    1. Isolate decorated areas (colored regions) from the ceramic body
    2. Apply adaptive edge detection tuned by deco_type
    3. Clean and vectorize edges into line art
    4. Generate SVG with proper scale
    """
    # Decode image from data URL
    try:
        b64_data = data_url.split(',')[1]
        img_bytes = base64.b64decode(b64_data)
        nparr = np.frombuffer(img_bytes, np.uint8)
        img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    except:
        return None
    
    if img is None:
        return None
    
    h, w = img.shape[:2]
    
    # ---- Step 1: Create decoration mask ----
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    lab = cv2.cvtColor(img, cv2.COLOR_BGR2Lab)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    # Detect colored decoration (saturated regions)
    s_ch = hsv[:, :, 1]
    v_ch = hsv[:, :, 2]
    h_ch = hsv[:, :, 0]
    
    # Decoration types affect processing
    if deco_type == "painted" or deco_type == "auto":
        # Painted: look for saturated color areas
        color_mask = (s_ch > 25).astype(np.uint8) * 255
        
        # Also check for strong luminance variation
        l_ch = lab[:, :, 0]
        l_mean = np.mean(l_ch)
        l_mask = (np.abs(l_ch.astype(float) - l_mean) > 20).astype(np.uint8) * 255
        deco_mask = cv2.bitwise_or(color_mask, l_mask)
        
    elif deco_type == "incised":
        # Incised: look for shadow lines (dark narrow features)
        clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(4, 4))
        enhanced = clahe.apply(gray)
        _, deco_mask = cv2.threshold(enhanced, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        
    elif deco_type == "stamped":
        # Stamped/relief: look for local height variation via shadow
        blur_large = cv2.GaussianBlur(gray, (31, 31), 0)
        local_diff = cv2.absdiff(gray, blur_large)
        _, deco_mask = cv2.threshold(local_diff, 15, 255, cv2.THRESH_BINARY)
        
    elif deco_type == "band":
        # Band decoration: horizontal/circular patterns
        blue_mask = cv2.inRange(hsv, np.array([90, 25, 40]), np.array([130, 255, 255]))
        color_general = (s_ch > 30).astype(np.uint8) * 255
        deco_mask = cv2.bitwise_or(blue_mask, color_general)
        
    elif deco_type == "figural":
        # Figural: strong contrast features
        clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(8, 8))
        enhanced = clahe.apply(gray)
        color_mask = (s_ch > 20).astype(np.uint8) * 255
        _, lum_mask = cv2.threshold(enhanced, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        deco_mask = cv2.bitwise_or(color_mask, lum_mask)
        
    elif deco_type == "ornamental":
        # Ornamental/geometric: regular patterns
        color_mask = (s_ch > 25).astype(np.uint8) * 255
        edges = cv2.Canny(gray, 30, 100)
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
        edges = cv2.dilate(edges, kernel, iterations=1)
        deco_mask = cv2.bitwise_or(color_mask, edges)
    else:
        deco_mask = (s_ch > 25).astype(np.uint8) * 255
    
    # Clean decoration mask
    kernel_small = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    kernel_med = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    deco_mask = cv2.morphologyEx(deco_mask, cv2.MORPH_CLOSE, kernel_small, iterations=2)
    deco_mask = cv2.morphologyEx(deco_mask, cv2.MORPH_OPEN, kernel_small, iterations=1)
    
    # ---- Step 2: Edge detection on decoration ----
    # Map sensitivity (10-100) to Canny thresholds
    canny_low = max(10, 120 - edge_sensitivity)
    canny_high = max(30, 200 - edge_sensitivity)
    
    # Multi-scale edge detection
    edges1 = cv2.Canny(gray, canny_low, canny_high)
    
    # Apply CLAHE for enhanced local contrast edges
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    enhanced = clahe.apply(gray)
    edges2 = cv2.Canny(enhanced, canny_low, canny_high)
    
    # Color channel edges
    b_ch, g_ch, r_ch = cv2.split(img)
    edges_b = cv2.Canny(b_ch, canny_low + 10, canny_high + 10)
    edges_g = cv2.Canny(g_ch, canny_low + 10, canny_high + 10)
    edges_r = cv2.Canny(r_ch, canny_low + 10, canny_high + 10)
    
    # Combine all edges
    all_edges = cv2.bitwise_or(edges1, edges2)
    all_edges = cv2.bitwise_or(all_edges, edges_b)
    all_edges = cv2.bitwise_or(all_edges, edges_g)
    all_edges = cv2.bitwise_or(all_edges, edges_r)
    
    # Focus on decoration area
    deco_edges = cv2.bitwise_and(all_edges, deco_mask)
    
    # Also keep strong edges in non-decoration areas (outlines)
    strong_edges = cv2.Canny(gray, canny_high, canny_high + 50)
    combined_edges = cv2.bitwise_or(deco_edges, strong_edges)
    
    # ---- Step 3: Clean and refine ----
    # Detail level controls morphological cleanup
    if detail_level < 30:
        # Less detail = more cleanup
        k = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
        combined_edges = cv2.morphologyEx(combined_edges, cv2.MORPH_CLOSE, k, iterations=2)
        combined_edges = cv2.morphologyEx(combined_edges, cv2.MORPH_OPEN, k, iterations=1)
    elif detail_level > 70:
        # More detail = minimal cleanup
        k = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))
        combined_edges = cv2.morphologyEx(combined_edges, cv2.MORPH_CLOSE, k, iterations=1)
    else:
        k = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2))
        combined_edges = cv2.morphologyEx(combined_edges, cv2.MORPH_CLOSE, k, iterations=1)
    
    # Remove very small components (noise)
    contours, _ = cv2.findContours(combined_edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    min_contour_area = max(5, (100 - detail_level) * 2)
    clean_edges = np.zeros_like(combined_edges)
    for c in contours:
        if cv2.contourArea(c) > min_contour_area or cv2.arcLength(c, False) > min_contour_area * 0.5:
            cv2.drawContours(clean_edges, [c], -1, 255, 1)
    
    # ---- Step 4: Create line drawing ----
    # White background, black lines
    lineart = np.ones((h, w, 3), dtype=np.uint8) * 250  # Slightly off-white like paper
    
    # Draw edges with specified thickness
    contours_final, _ = cv2.findContours(clean_edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_TC89_KCOS)
    
    for c in contours_final:
        # Approximate contour for smoother lines
        epsilon = max(0.5, (100 - detail_level) / 100.0 * 3.0)
        approx = cv2.approxPolyDP(c, epsilon, False)
        cv2.polylines(lineart, [approx], False, (30, 30, 30), line_thickness, cv2.LINE_AA)
    
    # Add fragment outline
    # Find the overall piece boundary
    piece_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    _, piece_mask = cv2.threshold(piece_gray, 240, 255, cv2.THRESH_BINARY_INV)
    piece_contours, _ = cv2.findContours(piece_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if piece_contours:
        largest = max(piece_contours, key=cv2.contourArea)
        cv2.drawContours(lineart, [largest], -1, (60, 60, 60), max(1, line_thickness), cv2.LINE_AA)
    
    # ---- Step 5: Generate SVG ----
    svg_paths = []
    for c in contours_final:
        epsilon = max(0.5, (100 - detail_level) / 100.0 * 3.0)
        approx = cv2.approxPolyDP(c, epsilon, False)
        if len(approx) >= 2:
            pts = approx.reshape(-1, 2)
            path_d = f"M {pts[0][0]},{pts[0][1]}"
            for pt in pts[1:]:
                path_d += f" L {pt[0]},{pt[1]}"
            svg_paths.append(path_d)
    
    # Add piece outline to SVG
    if piece_contours:
        largest = max(piece_contours, key=cv2.contourArea)
        outline_approx = cv2.approxPolyDP(largest, 2.0, True)
        if len(outline_approx) >= 3:
            pts = outline_approx.reshape(-1, 2)
            path_d = f"M {pts[0][0]},{pts[0][1]}"
            for pt in pts[1:]:
                path_d += f" L {pt[0]},{pt[1]}"
            path_d += " Z"
            svg_paths.insert(0, path_d)  # Outline first
    
    svg_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     viewBox="0 0 {w} {h}" 
     width="{w}" height="{h}">
  <title>ShardMind Decoration Line Drawing</title>
  <desc>Automatically extracted decoration from archaeological fragment</desc>
  <style>
    .outline {{ fill: none; stroke: #3c3c3c; stroke-width: {max(1, line_thickness)}; stroke-linecap: round; stroke-linejoin: round; }}
    .decoration {{ fill: none; stroke: #1e1e1e; stroke-width: {line_thickness}; stroke-linecap: round; stroke-linejoin: round; }}
  </style>
  <rect width="{w}" height="{h}" fill="#faf8f5"/>
'''
    
    if svg_paths:
        svg_content += f'  <path class="outline" d="{svg_paths[0]}"/>\n'
        for path_d in svg_paths[1:]:
            svg_content += f'  <path class="decoration" d="{path_d}"/>\n'
    
    svg_content += '</svg>'
    
    # ---- Dimensions estimate ----
    # Rough estimate: typical pottery shard is 3-15cm
    # Use area to estimate scale
    piece_area_px = 0
    if piece_contours:
        piece_area_px = cv2.contourArea(max(piece_contours, key=cv2.contourArea))
    
    # Estimate pixels per mm (rough heuristic)
    estimated_size_mm = 60  # assume ~60mm for a typical shard
    if piece_contours:
        x_, y_, bw_, bh_ = cv2.boundingRect(max(piece_contours, key=cv2.contourArea))
        max_dim = max(bw_, bh_)
        ppmm = max_dim / estimated_size_mm if estimated_size_mm > 0 else 1.0
    else:
        ppmm = max(w, h) / estimated_size_mm
    
    lineart_url = cv2_to_dataurl(lineart)
    
    return {
        'lineartDataUrl': lineart_url,
        'svgData': svg_content,
        'dimensions': {
            'width_px': int(w),
            'height_px': int(h),
            'width_mm': float(w / ppmm),
            'height_mm': float(h / ppmm),
            'ppmm': float(ppmm),
        }
    }


def py_extract_decoration(data_url, line_thickness, detail_level, edge_sensitivity, deco_type):
    """Called from JavaScript"""
    result = extract_decoration_lineart(
        str(data_url), 
        int(line_thickness), 
        int(detail_level), 
        int(edge_sensitivity), 
        str(deco_type)
    )
    
    if result is None:
        return to_js({'lineartDataUrl': None, 'svgData': None, 'dimensions': {}}, dict_converter=js.Object.fromEntries)
    
    return to_js(result, dict_converter=js.Object.fromEntries)


# =============================================================================
# REGISTER ALL PYTHON FUNCTIONS FOR JAVASCRIPT
# =============================================================================

try:
    update_loading("Registriere Funktionen...")
    js.window.py_analyze = create_proxy(py_analyze)
    js.window.py_cluster = create_proxy(py_cluster)
    js.window.py_reconstruct = create_proxy(py_reconstruct)
    js.window.py_extract_decoration = create_proxy(py_extract_decoration)
    
    # Signal ready
    set_py_ready()
    print("ShardMind Python engine ready!")

except Exception as e:
    error_msg = f"Registrierungs-Fehler: {str(e)[:100]}"
    print(f"[ShardMind ERROR] {error_msg}")
    set_py_error(error_msg)
</script>

<!-- Bridge functions between JS and Python -->
<script>
// These async functions bridge JS <-> PyScript

async function callPyAnalysis(uint8Array, minArea, mode, separation, project) {
    if (!window.py_analyze) {
        console.error("Python not ready");
        return [];
    }
    try {
        const result = window.py_analyze(uint8Array, minArea, mode, separation, project);
        // Convert PyProxy to plain JS array
        if (result && typeof result.toJs === 'function') {
            return result.toJs({dict_converter: Object.fromEntries});
        }
        // Try to convert proxy to array
        const arr = [];
        if (result && result.length !== undefined) {
            for (let i = 0; i < result.length; i++) {
                const item = result[i];
                if (typeof item.toJs === 'function') {
                    arr.push(item.toJs({dict_converter: Object.fromEntries}));
                } else {
                    arr.push(item);
                }
            }
        }
        return arr;
    } catch (err) {
        console.error("Analysis error:", err);
        return [];
    }
}

async function callPyClustering(pieces, threshold) {
    if (!window.py_cluster) {
        console.error("Python not ready");
        return pieces.map(() => 0);
    }
    try {
        // Convert pieces to simple objects for Python
        const simplified = pieces.map(p => ({
            color_features: p.color_features || [],
            material: p.material || '',
            area: p.area || 0,
            solidity: p.solidity || 0,
        }));
        const result = window.py_cluster(simplified, threshold);
        if (result && typeof result.toJs === 'function') {
            return result.toJs();
        }
        const arr = [];
        for (let i = 0; i < result.length; i++) arr.push(result[i]);
        return arr;
    } catch (err) {
        console.error("Clustering error:", err);
        return pieces.map(() => 0);
    }
}

async function callPyReconstruction(pieces, canvasSize) {
    if (!window.py_reconstruct) {
        console.error("Python not ready");
        return null;
    }
    try {
        const simplified = pieces.map(p => ({
            thumbnailDataUrl: p.thumbnailDataUrl || '',
            offset: p.offset || [0, 0],
            centroid: p.centroid || [0, 0],
            contour_global: p.contour_global || [],
            color_features: p.color_features || [],
        }));
        const result = window.py_reconstruct(simplified, canvasSize);
        if (result && typeof result.toJs === 'function') {
            return result.toJs({dict_converter: Object.fromEntries});
        }
        return result;
    } catch (err) {
        console.error("Reconstruction error:", err);
        return null;
    }
}
</script>

</body>
</html>
